package xmipp.jni; 
public class MDLabel {
   public static final int MDL_UNDEFINED = -1; ///
   public static final int MDL_FIRST_LABEL = 0;  ///< The label MDL_OBJID is special and should not be used
   public static final int MDL_OBJID = MDL_FIRST_LABEL;  ///< object id (int), NOTE: This label is special and shouldn't be used
   public static final int MDL_ANGLE_COMPARISON = 1;  ///< Angular comparison (see angular_distance.cpp)
   public static final int MDL_ANGLEPSI = 2;  ///< Psi angle of an image (double,degrees)
   public static final int MDL_ANGLEPSI2 = 3;  ///< Psi angle of an image (double,degrees)
   public static final int MDL_ANGLEROT = 4;  ///< Rotation angle of an image (double,degrees)
   public static final int MDL_ANGLEROT2 = 5;  ///< Rotation angle of an image (double,degrees)
   public static final int MDL_ANGLETILT = 6;  ///< Tilting angle of an image (double,degrees)
   public static final int MDL_ANGLETILT2 = 7;  ///< Tilting angle of an image (double,degrees)
   public static final int MDL_ANGLE_Y = 8;    ///< Angle between y-axis and tilt-axis (double, degrees) for untilted micrographs
   public static final int MDL_ANGLE_Y2 = 9;    ///< Angle between y-axis and tilt-axis (double, degrees) for tilted micrographs
   public static final int MDL_ASSOCIATED_IMAGE1 = 10;  ///< Image associated to this object (std::string)
   public static final int MDL_ASSOCIATED_IMAGE2 = 11;  ///< Image associated to this object (std::string)
   public static final int MDL_ASSOCIATED_IMAGE3 = 12;  ///< Image associated to this object (std::string)
   public static final int MDL_ASSOCIATED_IMAGE4 = 13;  ///< Image associated to this object (std::string)
   public static final int MDL_ASSOCIATED_IMAGE5 = 14;  ///< Image associated to this object (std::string)
   public static final int MDL_AVG = 15;  ///< average value (double)
   public static final int MDL_AZIMUTALANGLE = 16;  ///< ctf definition azimutal angle
   public static final int MDL_BGMEAN = 17;  ///< Mean background value for an image
   public static final int MDL_BLOCK = 18;  ///< Current block number (for incremental EM)
   public static final int MDL_CELLX = 19;  ///< Cell location for crystals
   public static final int MDL_CELLY = 20;  ///< Cell location for crystals
   public static final int MDL_CL2D_CHANGES = 21;  ///< Number of changes between iterations
   public static final int MDL_CL2D_SIMILARITY = 22;  ///< Average cross-correlation for the image (double)
   public static final int MDL_CLASS_COUNT = 23;  ///< Number of images assigned to the same class as this image
   public static final int MDL_CLASSIFICATION_DATA = 24;  ///< Data vector for classification (vector double)
   public static final int MDL_CLASSIFICATION_DATA_SIZE = 25;  ///< Size of data vectors for classification (int)
   public static final int MDL_CLASSIFICATION_DPR_05 = 26;  ///< Differential Phase Residual evaluated at FRC=0.5
   public static final int MDL_CLASSIFICATION_INTRACLASS_DISTANCE = 27;  ///< Average intraclass distance (double)
   public static final int MDL_CLASSIFICATION_FRC_05 = 28;  ///< Digital frequency at which the FRC drops below 0.5 (double)
   public static final int MDL_COMMENT = 29;  ///< A comment for this object /*** NOTE THIS IS A SPECIAL CASE AND SO IS TREATED ***/
   public static final int MDL_COST = 30;  ///< Cost for the image (double)
   public static final int MDL_COUNT = 31;  ///< Number of elements of a type (int) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_COUNT2 = 32;  ///< Number of elements of a type (int) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_CTFINPUTPARAMS = 33;  ///< Parameters file for the CTF Model (std::string)
   public static final int MDL_CTFMODEL = 34;  ///< Name for the CTF Model (std::string)
   public static final int MDL_CTFMODEL2 = 35;  ///< Name for another CTF model (std::string)
   public static final int MDL_CTF_SAMPLING_RATE = 36;  ///< Sampling rate
   public static final int MDL_CTF_SAMPLING_RATE_Z = 37;  ///< Sampling rate in Z direction
   public static final int MDL_CTF_VOLTAGE = 38;  ///< Microscope voltage (kV)
   public static final int MDL_CTF_DEFOCUSA = 39;  ///< aver (Angage defocusstroms)
   public static final int MDL_CTF_DEFOCUSU = 40;  ///< Defocus U (Angstroms)
   public static final int MDL_CTF_DEFOCUSV = 41;  ///< Defocus V (Angstroms)
   public static final int MDL_CTF_DEFOCUS_ANGLE = 42;  ///< Defocus angle (degrees)
   public static final int MDL_CTF_CS = 43;  ///< Spherical aberration
   public static final int MDL_CTF_CA = 44;  ///< Chromatic aberration
   public static final int MDL_CTF_GROUP = 45;  ///< group images by defocus
   public static final int MDL_CTF_ENERGY_LOSS = 46;  ///< Energy loss
   public static final int MDL_CTF_LENS_STABILITY = 47;  ///< Lens stability
   public static final int MDL_CTF_CONVERGENCE_CONE = 48;  ///< Convergence cone
   public static final int MDL_CTF_LONGITUDINAL_DISPLACEMENT = 49;  ///< Longitudinal displacement
   public static final int MDL_CTF_TRANSVERSAL_DISPLACEMENT = 50;  ///< Transversal displacemente
   public static final int MDL_CTF_Q0 = 51;  ///< Inelastic absorption
   public static final int MDL_CTF_K = 52;  ///< CTF gain
   public static final int MDL_CTFBG_GAUSSIAN_K = 53;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN_SIGMAU = 54;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN_SIGMAV = 55;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN_CU = 56;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN_CV = 57;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN_ANGLE = 58;  ///< CTF Background parameter
   public static final int MDL_CTFBG_SQRT_K = 59;  ///< CTF Background parameter
   public static final int MDL_CTFBG_SQRT_U = 60;  ///< CTF Background parameter
   public static final int MDL_CTFBG_SQRT_V = 61;  ///< CTF Background parameter
   public static final int MDL_CTFBG_SQRT_ANGLE = 62;  ///< CTF Background parameter
   public static final int MDL_CTFBG_BASELINE = 63;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN2_K = 64;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN2_SIGMAU = 65;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN2_SIGMAV = 66;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN2_CU = 67;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN2_CV = 68;  ///< CTF Background parameter
   public static final int MDL_CTFBG_GAUSSIAN2_ANGLE = 69;  ///< CTF Background parameter
   public static final int MDL_CTF_CRITERION_PSDCORRELATION90 = 70;  ///< PSD correlation at 90 degrees
   public static final int MDL_CTF_CRITERION_FIRSTZERORATIO = 71;  ///< First zero ratio
   public static final int MDL_CTF_CRITERION_FIRSTZEROAVG = 72;  ///< First zero average (in Angstroms)
   public static final int MDL_CTF_CRITERION_FIRSTZERODISAGREEMENT = 73;  ///< First zero disagreement with second model (in Angstroms)
   public static final int MDL_CTF_CRITERION_DAMPING = 74;  ///< Minimum damping at border
   public static final int MDL_CTF_CRITERION_PSDRADIALINTEGRAL = 75;  ///< Integral of the radial PSD
   public static final int MDL_CTF_CRITERION_FITTINGSCORE = 76;  ///< Score of the fitting
   public static final int MDL_CTF_CRITERION_FITTINGCORR13 = 77;  ///< Correlation between the 1st and 3rd ring of the CTF
   public static final int MDL_CTF_CRITERION_PSDVARIANCE = 78;  ///< PSD variance
   public static final int MDL_CTF_CRITERION_PSDPCA1VARIANCE = 79;  ///< Variance in the first principal component of the PSDs
   public static final int MDL_CTF_CRITERION_PSDPCARUNSTEST = 80;  ///< Runs test on the projection of the PSD on the first principal component
   public static final int MDL_CTF_CRITERION_NORMALITY = 81;  ///< Normality test between histogram of micrography and gaussian distribution
   public static final int MDL_CTF_DOWNSAMPLE_PERFORMED = 82;  ///< Downsampling performed to estimate the CTF
   public static final int MDL_CTF_XRAY_DIMENSIONS = 83; // Size in pixels of the 3D PSF to be created (Xdim = 83; Ydim = 83; Zdim) ///
   public static final int MDL_CTF_XRAY_LAMBDA = 84;  /// X-ray wavelength (nm)
   public static final int MDL_CTF_XRAY_LENS_TYPE = 85;  ///Algorithm used to generate Xray PSF
   public static final int MDL_MAGNIFICATION = 86;  /// Magnification of the X-ray microscope
   public static final int MDL_CTF_XRAY_OUTER_ZONE_WIDTH = 87;  /// Outermost zone width of the X-ray Fresnel lens (nm)
   public static final int MDL_CTF_XRAY_ZONES_NUMBER = 88; // Number of zones of the X-ray Fresnel lens ///
   public static final int MDL_DATATYPE = 89;  ///< if read from file original image datatype, this is an struct defined in image
   public static final int MDL_DEFGROUP = 90;  ///< Defocus group
   public static final int MDL_DIRECTION = 91;  ///< Direction in 3D
   public static final int MDL_DM3_IDTAG = 92; ///
   public static final int MDL_DM3_NODEID = 93; ///
   public static final int MDL_DM3_NUMBER_TYPE = 94; ///
   public static final int MDL_DM3_PARENTID = 95; ///
   public static final int MDL_DM3_TAGCLASS = 96; ///
   public static final int MDL_DM3_TAGNAME = 97; ///
   public static final int MDL_DM3_SIZE = 98; ///
   public static final int MDL_DM3_VALUE = 99; ///
   public static final int MDL_ENABLED = 100;  ///< Is this image enabled? (int [-1 or 1])
   public static final int MDL_FLIP = 101;  ///< Flip the image? (bool)
   public static final int MDL_FOM = 102;  ///< Figure of Merit in 0-1 range (double)
   public static final int MDL_IDX = 103;  ///< Index within a list (size_t)
   public static final int MDL_IMAGE = 104;  ///< Name of an image (std::string)
   public static final int MDL_IMAGE_ORIGINAL = 105;  ///< Name of an image from which MDL_IMAGE is coming from
   public static final int MDL_IMAGE_TILTED = 106;  ///< Name of the tilted images associated to MDL_IMAGE
   public static final int MDL_IMGMD = 107;  ///< Name of Metadata file for all images (string)
   public static final int MDL_INTSCALE = 108;  ///< Intensity scale for an image
   public static final int MDL_ITER = 109;  ///< Current iteration number (int)
   public static final int MDL_K = 110;  ///< //ctf definition K
   public static final int MDL_KERDENSOM_FUNCTIONAL = 111;  ///< Functional value (double)
   public static final int MDL_KERDENSOM_REGULARIZATION = 112;  ///< Regularization value (double)
   public static final int MDL_KERDENSOM_SIGMA = 113;  ///< Sigma value (double)
   public static final int MDL_KEYWORDS = 114;  ///< Keywords associated to this line, should be a single string block (do not use spaces as separators)
   public static final int MDL_KSTEST = 115;  ///<KS-test statistics
   public static final int MDL_LL = 116;  ///< contribution of an image to log-likelihood value
   public static final int MDL_MAPTOPOLOGY = 117;  ///< Map topology (KerDenSOM, ...)
   public static final int MDL_MASK = 118;  ///< Name of a mask associated to image
   public static final int MDL_MAXCC = 119;  ///< Maximum cross-correlation for the image (double)
   public static final int MDL_MAX = 120;  ///<maximum value (double)
   public static final int MDL_MICROGRAPH = 121;  ///< Name of a micrograph (std::string)
   public static final int MDL_MICROGRAPH_TILTED = 122;  ///< Name of the corresponding tilted micrograph (std::string)
   public static final int MDL_MIN = 123;  ///<minimum value (double)
   public static final int MDL_MIRRORFRAC = 124;  ///< Mirror fraction for a Maximum Likelihood model
   public static final int MDL_MISSINGREGION_NR = 125;  ///< Number of missing region in subtomogram
   public static final int MDL_MISSINGREGION_TYPE = 126;  ///< Type of missing region in subtomogram
   public static final int MDL_MISSINGREGION_THY0 = 127;  ///< Initial tilt angle in Y for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THYF = 128;  ///< Final tilt angle in Y for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THX0 = 129;  ///< Initial tilt angle in X for missing region in subtomogram
   public static final int MDL_MISSINGREGION_THXF = 130;  ///< Final tilt angle in X for missing region in subtomogram
   public static final int MDL_MODELFRAC = 131;  ///< Model fraction (alpha_k) for a Maximum Likelihood model
   public static final int MDL_NEIGHBORS = 132;  ///< Vector of indexes to points some "neighbors"
   public static final int MDL_NEIGHBOR = 133;  ///particular neighbor (pointed myNEIGHBORS)
   public static final int MDL_NEIGHBORHOOD_RADIUS = 134;  ///< Radius of the neigborhood (radians)
   public static final int MDL_NMA = 135;  ///< Normal mode displacements (vector double)
   public static final int MDL_NMA_MODEFILE = 136;  ///< File with an NMA mode
   public static final int MDL_NOISE_ANGLES = 137;  ///< Noise description for projected angles
   public static final int MDL_NOISE_PARTICLE_COORD = 138;  ///< Noise description for particle's center coordenates (when projecting)
   public static final int MDL_NOISE_COORD = 139;  //Use instead of MDL_NOISE_PARTICLE_COORD in future ///
   public static final int MDL_NOISE_PIXEL_LEVEL = 140;  ///< Noise description for pixels' gray level (when projecting)
   public static final int MDL_ORDER = 141;  /// auxiliary label to be used as an index (long)
   public static final int MDL_ORIGINX = 142;  ///< Origin for the image in the X axis (double)
   public static final int MDL_ORIGINY = 143;  ///< Origin for the image in the Y axis (double)
   public static final int MDL_ORIGINZ = 144;  ///< Origin for the image in the Z axis (double)
   public static final int MDL_PICKING_COLOR = 145;  ///< Color for particle picking
   public static final int MDL_PICKING_FAMILY = 146;  ///< Family for particle picking
   public static final int MDL_PICKING_FAMILY_STATE = 147;  ///< Family state for particle picking
   public static final int MDL_PICKING_MICROGRAPH_FAMILY_STATE = 148;  ///< Micrograph family state for particle picking
   public static final int MDL_PICKING_PARTICLE_SIZE = 149;  ///< Particle size for particle picking
   public static final int MDL_PMAX = 150;  ///< Maximum value of normalized probability function (now called "Pmax/sumP") (double)
   public static final int MDL_POINTSASYMETRICUNIT = 151; //number of points in asymmetric unit ///
   public static final int MDL_PRJ_DIMENSIONS = 152; // X = 152;Y dimensions for the generated projections ///
   public static final int MDL_PRJ_TILT_RANGE = 153; // Vector with the initial and final tilt angle values = 153; and step size ///
   public static final int MDL_PRJ_VOL = 154;        // Volume file name to generate projections from ///
   public static final int MDL_DIMENSIONS_3D = 155;  // X = 155;Y = 155;Z dimensions ///
   public static final int MDL_DIMENSIONS_2D = 156;  // X = 156;Y dimensions ///
   public static final int MDL_PSD = 157;  ///< A Power Spectrum Density file name (std::string)
   public static final int MDL_PSD_ENHANCED = 158;  ///< A enhanced Power Spectrum Density file name (std::string)
   public static final int MDL_RANDOMSEED = 159;  ///< Seed for random number generator
   public static final int MDL_REF3D = 160;  ///< 3D Class to which the image belongs (int)
   public static final int MDL_REF = 161;  ///< Class to which the image belongs (int)
   public static final int MDL_REFMD = 162;  ///< Name of Metadata file for all references(string)
   public static final int MDL_RESOLUTION_DPR = 163;  ///<differential phase residual (double)
   public static final int MDL_RESOLUTION_ERRORL2 = 164;  ///<Error in l2 (double)
   public static final int MDL_RESOLUTION_FRC = 165;  ///<Fourier shell correlation (double)
   public static final int MDL_RESOLUTION_FRCRANDOMNOISE = 166;  ///<Fourier shell correlation noise (double)
   public static final int MDL_RESOLUTION_FREQ = 167;  ///<Frequency in 1/A (double)
   public static final int MDL_RESOLUTION_FREQREAL = 168;  ///< Frequency in A (double)
   public static final int MDL_SAMPLINGRATE = 169;  ///< sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATEX = 170;  ///< sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATEY = 171;  ///< sampling rate in A/pixel (double)
   public static final int MDL_SAMPLINGRATEZ = 172;  ///< sampling rate in A/pixel (double)
   public static final int MDL_SCALE = 173;  ///< scaling factor for an image or volume (double)
   public static final int MDL_SELFILE = 174;  ///< Name of an image (std::string)
   public static final int MDL_SERIE = 175;  ///< A collection of micrographs, e.g. a tilt serie (std::string)
   public static final int MDL_SHIFTX = 176;  ///< Shift for the image in the X axis (double)
   public static final int MDL_SHIFTY = 177;  ///< Shift for the image in the Y axis (double)
   public static final int MDL_SHIFTZ = 178;  ///< Shift for the image in the Z axis (double)
   public static final int MDL_SHIFT_CRYSTALX = 179;  ///< Shift for the image in the X axis (double) for crystals
   public static final int MDL_SHIFT_CRYSTALY = 180;  ///< Shift for the image in the Y axis (double) for crystals
   public static final int MDL_SHIFT_CRYSTALZ = 181;  ///< Shift for the image in the Z axis (double) for crystals
   public static final int MDL_SIGMANOISE = 182;  ///< Standard deviation of the noise in ML model
   public static final int MDL_SIGMAOFFSET = 183;  ///< Standard deviation of the offsets in ML model
   public static final int MDL_SIGNALCHANGE = 184;  ///< Signal change for an image
   public static final int MDL_SPHERICALABERRATION = 185;  ///<ctf definition azimutal angle
   public static final int MDL_STDDEV = 186;  ///<stdandard deviation value (double)
   public static final int MDL_SUM = 187;  ///< Sum of elements of a given type (double) [this is a genereic type do not use to transfer information to another program]
   public static final int MDL_SUMWEIGHT = 188;  ///< Sum of all weights in ML model
   public static final int MDL_SYMNO = 189;  ///< Symmetry number for a projection (used in ART)
   public static final int MDL_TRANSFORMATIONMTRIX = 190;  ///< transformation matrix(vector double)
   public static final int MDL_VOLTAGE = 191;  ///< microscope voltage (double)
   public static final int MDL_WEIGHT = 192;  ///< Weight assigned to the image (double)
   public static final int MDL_WROBUST = 193;  ///< Weight of t-student distribution in robust Maximum likelihood
   public static final int MDL_X = 194;  ///< X component (double)
   public static final int MDL_XINT = 195;  ///< X component (int)
   public static final int MDL_XINTTILT = 196;  ///< X component in tilted micrograph (int)
   public static final int MDL_XSIZE = 197;  ///< X size (int)
   public static final int MDL_Y = 198;  ///< Y component (double)
   public static final int MDL_YINT = 199;  ///< Y component (int)
   public static final int MDL_YINTTILT = 200;  ///< Y component in tilted micrograph (int)
   public static final int MDL_YSIZE = 201;  ///< Y size (int)
   public static final int MDL_Z = 202;  ///< Z component (double)
   public static final int MDL_ZINT = 203;  ///< Z component (int)
   public static final int MDL_ZSCORE = 204;  ///< Z Score (double)
   public static final int MDL_ZSIZE = 205;  ///< Z size (int)
   public static final int MDL_PHANTOM_BGDENSITY = 206;  ///< Phantom background density (double)
   public static final int MDL_PHANTOM_SCALE = 207;  ///< Number which will multiply all features (double)
   public static final int MDL_PHANTOM_FEATURE_TYPE = 208;  ///< Type of the feature (Sphere, Blob, ...) (std::string)
   public static final int MDL_PHANTOM_FEATURE_OPERATION = 209;  ///< Operation in case of overlapping features (+,-)
   public static final int MDL_PHANTOM_FEATURE_DENSITY = 210;  ///< The density of the feature (double)
   public static final int MDL_PHANTOM_FEATURE_CENTER = 211;  ///< Center of the feature (vector double)
   public static final int MDL_PHANTOM_FEATURE_SPECIFIC = 212;  ///< Specific parameters for a feature (vector double)
   public static final int MDL_PRJ_ANGFILE = 213;   ///< File for generated angles
   public static final int MDL_PRJ_ROT_RANGE = 214; ///
   public static final int MDL_PRJ_ROT_Noise  = 215;   /// < Rotational angle dev and mean noise (vector double)
   public static final int MDL_PRJ_ROT_RANDSTR = 216;   /// < Type of randomness for Rotational (std::string)
   public static final int MDL_PRJ_TILT_Noise = 217;   /// < Tilt angle dev and mean noise (vector double)
   public static final int MDL_PRJ_TILT_RANDSTR = 218;   /// < Type of randomness for Tilt (std::string)
   public static final int MDL_PRJ_PSI_RANGE = 219;   /// < Psi angle range (vector double)
   public static final int MDL_PRJ_PSI_Noise = 220;   /// < Psi angle dev and mean noise (vector double)
   public static final int MDL_PRJ_PSI_RANDSTR = 221;  /// < Type of randomness for Psi (std::string)
   public static final int MDL_2D_LATTICE_VECA = 222;    /// < Lattice vector for projection (vector double)
   public static final int MDL_2D_LATTICE_VECB = 223;    /// < Lattice vector for projection (vector double)
   public static final int MDL_CRYSTAL_DISAPPEAR_THRE = 224;    /// < Disappearing threshold (double)
   public static final int MDL_CRYSTAL_SHFILE = 225;    /// < Shift file for crystal projection
   public static final int MDL_ORTHOGONAL_PROJECTION = 226;    /// <Orthogonal projection or not (bool)
   public static final int MDL_CRYSTAL_PROJ = 227;    /// < Have a crystal projection (boo)
   public static final int MDL_LAST_LABEL = 228;  // **** NOTE ****: Do keep this label always at the end;it is here for looping purposes ///
}
