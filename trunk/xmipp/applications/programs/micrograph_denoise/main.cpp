/***************************************************************************
 *
 * Authors:     Carlos Oscar S. Sorzano (coss@cnb.csic.es) (2002)
 *
 * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307  USA
 *
 *  All comments concerning this program package may be sent to the
 *  e-mail address 'xmipp@cnb.csic.es'
 ***************************************************************************/

#include <data/args.h>
#include <data/micrograph.h>
#include <reconstruction/denoise.h>

void Usage();

int main(int argc, char **argv)
{
    Micrograph     M_in,  M_out;
    FileName       fn_in, fn_out;
    Denoising_parameters prm;
    int            window_size;
    bool           reversed;

    // Get command line parameters ------------------------------------------
    try
    {
        fn_in       = getParameter(argc, argv, "-i");
        fn_out      = getParameter(argc, argv, "-o");
        window_size = textToInteger(getParameter(argc, argv, "-window_size", "128"));
        reversed    = checkParameter(argc, argv, "-reverse_endian");
        prm.read(argc, argv);
        prm.adjust_range = false;
        prm.produce_side_info();
    }
    catch (Xmipp_error XE)
    {
        std::cerr << XE;
        Usage();
        exit(1);
    }

    // Main program ---------------------------------------------------------
    try
    {
        // Read input micrograph
        M_in.open_micrograph(fn_in, reversed);
        int bits = 32;
        int Ydim, Xdim;
        M_in.size(Xdim, Ydim);

        // Create output image
        std::cerr << "Creating output micrograph ...\n";
        create_empty_file(fn_out, (bits / 8)*Ydim*Xdim);

        std::ofstream fh_inf;
        fh_inf.open((fn_out + ".inf").c_str());
        if (!fh_inf)
            REPORT_ERROR(1, (std::string)"Window_Micrograph: Cannot open " + fn_out +
                         ".inf");
        fh_inf << "# Generated by denoising micrograph\n";
        fh_inf << "# Original file: " << fn_in << std::endl;
        fh_inf << "# Image width\n";
        fh_inf << "Xdim=" << Xdim << std::endl;
        fh_inf << "# Image length\n";
        fh_inf << "Ydim=" << Ydim << std::endl;
        fh_inf << "# Pixel depth\n";
        fh_inf << "bitspersample=" << bits << std::endl;
        fh_inf.close();

        // Compute maximum and minimum of input micrograph
        std::cerr << "Scaling input micrograph ...\n";
        double min_val = M_in(0, 0), max_val = min_val;
        for (int i = 0; i < Ydim; i++)
            for (int j = 0; j < Xdim; j++)
            {
                double val = M_in(j, i);
                if (val > max_val) max_val = val;
                else if (val < min_val) min_val = val;
            }
        double a = 1 / (max_val - min_val);

        // Really denoise
        M_out.open_micrograph(fn_out);

        // Divide the micrograph into pieces
        int overlapping = 0;
        if (prm.denoising_type == Denoising_parameters::SHAH)
            overlapping = 2 * prm.Shah_outer;
        int Xpieces = CEIL((double)Xdim / (window_size - overlapping));
        int Ypieces = CEIL((double)Ydim / (window_size - overlapping));

        Matrix2D<double> img;
        std::cerr << "Denoising micrograph ...\n";
        init_progress_bar(Ypieces*Xpieces);
        int N = 0;
        for (int I = 0; I < Ypieces; I++)
            for (int J = 0; J < Xpieces; J++, N++)
            {
                int i0 = I * (window_size - overlapping);
                int j0 = J * (window_size - overlapping);
                int iF = i0 + window_size - 1;
                int jF = j0 + window_size - 1;
                if (iF >= Ydim)
                {
                    iF = Ydim - 1;
                    i0 = iF - window_size + 1;
                    if (i0 < 0) i0 = 0;
                }
                if (jF >= Xdim)
                {
                    jF = Xdim - 1;
                    j0 = jF - window_size + 1;
                    if (j0 < 0) j0 = 0;
                }

#ifdef DEBUG
                std::cout << "(I,J)=(" << I << "," << J << ") (i0,j0)=("
                          << i0 << "," << j0 << ") (iF,jF)=("
                          << iF << "," << jF << ")\n";
#endif

                // Read piece from file
                img.resize(iF - i0 + 1, jF - j0 + 1);
                for (int i = i0; i <= iF; i++)
                    for (int j = j0; j <= jF; j++)
                        img(i - i0, j - j0) = a * (M_in(j, i) - min_val);

                // Denoise
                prm.denoise(img);

                // Save image to file
                int i0p = (I == 0) ? i0 : i0 + overlapping / 2;
                int j0p = (J == 0) ? j0 : j0 + overlapping / 2;
                int iFp = (I == Ypieces - 1) ? iF : iF - overlapping / 2;
                int jFp = (J == Xpieces - 1) ? jF : jF - overlapping / 2;

                for (int i = i0p; i <= iFp; i++)
                    for (int j = j0p; j <= jFp; j++)
                    {
                        M_out.set_val(j, i, img(i - i0, j - j0));
                    }

                progress_bar(N);
            }
        progress_bar(Ypieces*Xpieces);

        // Close
        M_out.close_micrograph();
        M_in.close_micrograph();
    }
    catch (Xmipp_error XE)
    {
        std::cerr << XE;
        exit(1);
    }
    exit(0);
}

void Usage()
{
    std::cout << "Purpose:\n"
              << "    Denoise a microgrograph\n"
              << "Usage: denoising_micrograph\n"
              << "   -i <input_micrograph>     : Either 8 or 16 bits\n"
              << "   -o <output_micrograph>    : It will be rewritten\n"
              << "  [-window_size <n=128>]     : Size of the window\n"
              << std::endl;
    Denoising_parameters prm;
    prm.usage_specific();
}
