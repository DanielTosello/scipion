/***************************************************************************
 *
 * Authors:     Roberto Marabini (roberto@mipg.upenn.edu)
 *
 * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307  USA
 *
 *  All comments concerning this program package may be sent to the
 *  e-mail address 'xmipp@cnb.uam.es'
 ***************************************************************************/
/*****************************************************************************/
/* APH Files: MRC                                                            */
/*****************************************************************************/

#ifndef _XMIPP_APHorigmerg_HH
#define _XMIPP_APHorigmerg_HH

#include <data/funcs.h>
#include <data/matrix3d.h>
#include <data/geometry.h>
#include <reconstruction/symmetries.h>

#include <vector>
#include <iostream>
#include <algorithm>

/**@defgroup APHOrig APH origmerg
   @ingroup InterfaceLibrary */
//@{
/// Spot structure
struct spot
{
    int h;
    int k;
    double zstar;
    double amp;
    double phase;
    int    FILM;
    int    IQ;
    double FLMWGT;
    double BACK;
    double myCTF;
//   spot& operator= (const spot& B)  {
//      h = B.h;
//      k = B.k;
//   }
    bool operator<(const spot& B) const
    {
        if (h < B.h) return true;
        if (h == B.h && k < B.k) return true;
        return false;
    }

};

/// Show a spot
ostream &operator<<(ostream &os, const spot &s);

// function for sorting elements in ascending order
//  bool operator<(  spot A, spot B )
//  {
//      if (A.h < B.h) return TRUE;
//      if (A.k < B.k) return TRUE;
//       return FALSE;
//  }

/** APH Origmerg Files.
    This is a class to read APH files  produced by the MRC's program
    origtiltd.
    @code
         1
    0   1 -0.0018    1916.8 -163.6      5  1 1.00000      67.7  0.000
    0   2 -0.0036    1095.9 -147.0      5  1 1.00000      24.2  0.000
    0   3 -0.0054    1933.1   50.2      5  1 1.00000      46.0  0.000
    H,  K, ZSTAR,    AMP,PHS,FILM,IQwithSIGN,FLMWGT,   BACKground,CTF
    @endcode

    First line is ignored
    */
class APHFileorigmerg
{
public:
    /** APH Filename */
    FileName fn_aph;
    /** Pointer to a SPOT vector */
    vector<spot> aph_data_vector;
//   struct spot  * aph_data_array[];
#ifdef REMOVE //No needed since we use a vector v.size()
    /** number of spots */
    int spots_number;
#endif
    /** max h*/
    int max_h;
    /** min h*/
    int min_h;
    /** max k*/
    int max_k;
    /** min k*/
    int min_k;
    /** Read only entrie with this mrc_label mrc_label */
    int read_mrc_label;
public:
    /** Read an aph file generated by the MRC program origmerg.
        First line is skipped. A vector of SPOT structs is created
        with the data, number of epots is in spots_number.
      */
    void read(const FileName &fn, const int mrc_label);
    /** write aph-origtiltd like files */
    void write(const FileName &fn) const;
    /** Empties actual APH structure. */
    void clear();
    /** Move spots from assymetric unit to the plane  h>0
        those points that do not fit in the plane are ignored
        Will be used in the future. Need a,b magnitude (real space A)
        taxa,tilt.anglefrom a to  (radians), */
    void unasymmetrization(const double a_mag,   const  double b_mag,
                           const double mrc_taxa, const  double mrc_tilt,
                           const double a_b_ang, const  int symmetry_group,
                           Matrix2D<int> &Counter);
    /** Unsymmetrice for P222_1 symmetry, should be called only by
    unasymmetrization*/
    void unsymmetrice_P222_1(const double a_mag,    const double b_mag,
                             const double mrc_taxa, const double mrc_tilt,
                             const double a_b_ang,  const int symmetry_group,
                             Matrix2D<int> &Counter);
    /** Compute value of Z coordinate for a given taxa,tilt pair
        */
    void compute_Z(double a_mag, double b_mag,
                   double mrc_taxa, double mrc_tilt,
                   double a_b_ang, double &h_contrib, double &k_contrib);
};
//@}
#endif
