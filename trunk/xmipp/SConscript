#!/usr/bin/env python

Import('env')

# Required for custom functions
import os

FFTWDir = "external/fftw-3.2.2"
FFTWLibs = ['fftw3', 'fftw3_threads']
TIFFDir = "external/tiff-3.9.4"
TIFFLibs = ['tiff']
ARPACKppDir = "external/arpack++-2.3"
ARPACKppLibs = ['arpack++']
SQliteDir = "external/sqlite-3.6.23"
SQLiteLibs = ['sqlite3']

#PYSQliteDir = "external/pysqlite-2.6.3"

PythonDir = "external/python/Python-2.7.2"
PythonLibs = []

PluginLibs = {}
PluginResources = {}
javaEnumDict = {'ImageWriteMode': ['libraries/data/xmipp_image_base.h', 'WRITE_'],
            'CastWriteMode': ['libraries/data/xmipp_image_base.h', 'CW_'],
            'MDLabel': ['libraries/data/metadata_label.h', 'MDL_']}

copyJar = None

def AddMatchingFiles((pattern, blacklist, sources), directory, files):
    ''' Callback, adds all matching files in dir '''
    import fnmatch
    for file in fnmatch.filter(files, pattern):
        if file not in blacklist:
           # DBG print 'Adding ' + os.path.join(directory, file)
           sources.append(os.path.join(directory, file))

def Glob(dir, pattern, blacklist):
    ''' Custom made globbing '''
    import os
    sources = []
    os.path.walk(dir, AddMatchingFiles, (pattern, blacklist, sources))
    return sources

def AddLastSlash(string):
    ''' Low trick for correct parsing of paths '''
    str = string.strip();
    if len(str) == 0:
        return "";
    if not str.endswith('/'):
        str = str + '/'
    return str

def SymLink(target, source, env):
    #As the link will be in bin/ directory we need to move up
    link = str(target[0])
    source = os.path.relpath(str(source[0]),os.path.split(link)[0])
    os.symlink(source, link)

def AddProgramLink(target, source, PrependXmipp=True):
    binprefix = os.path.join(env['prefix'], 'bin')
    bintarget = os.path.join(binprefix, env['prepend']+target)
    if PrependXmipp:
        binsource = os.path.join(binprefix, env['prepend']+source)
    else:
        binsource = source
    command = env.Command(bintarget, binsource,  
        [Chmod('$SOURCE', 0755), SymLink])
    alias = env.Alias(target, command)
    env.Default(alias)
    return command

def AddBatch(name, basedir, extension=''):
    # setup
    basedir = AddLastSlash(basedir)
    fullname = env['prepend'] + name
    binprefix = os.path.join(env['prefix'], 'bin')

    # action
    source = os.path.join(basedir, 'batch_' + name + extension)
    target = os.path.join(binprefix, fullname)
    command = env.Command(target, source,  
        [Chmod('$SOURCE', 0755), SymLink])

    # alias
    alias = env.Alias(fullname, command)
    # Consider batch also as xmipp_programs
    env.Alias('xmipp_programs', command)
    #install = env.Install(binprefix, command)
    #env.Alias(fullname, install)
    env.Default(alias)
    return command

def AddProgram(name, basedir, sources_pattern='*.cpp', skip_list=[],
               includes=[], libpath=[], libs=[], cxxflags=[],
               linkflags=[]):
    ''' add a new program to the build list '''
    # setup
    basedir = AddLastSlash(basedir)
    fullname = env['prepend'] + name
    sources = Glob(basedir, sources_pattern, skip_list)
    binprefix = os.path.join(env['prefix'], 'bin')

    # FIXME fix for static executables
    if env['static']:
        cxxflags += [env['STATIC_FLAG']]
        linkflags += [env['STATIC_FLAG']]

    # action
    program = env.Program(
        os.path.join(basedir, fullname),
        sources,
        CPPPATH=includes + [env['CPPPATH']],
        LIBPATH=libpath + [env['LIBPATH']],
        LIBS=libs + [env['LIBS']],
        CXXFLAGS=cxxflags + [env['CXXFLAGS']],
        LINKFLAGS=linkflags + [env['LINKFLAGS']],
        LINK=env['LINKERFORPROGRAMS']
        )

    install = env.Install(binprefix, program)
    alias = env.Alias(fullname, install)
    env.Default(alias)
    return alias

def AddMPIProgram(name, basedir, sources_pattern='*.cpp', skip_list=[],
                  includes=[], libpath=[], libs=[], cxxflags=[],
                  linkflags=[]):

    # setup
    basedir = AddLastSlash(basedir)
    fullname = env['prepend'] + name
    sources = Glob(basedir, sources_pattern, skip_list)
    binprefix = os.path.join(env['prefix'], 'bin')

    # FIXME fix for static executables
    if env['static']:
        cxxflags += [env['STATIC_FLAG']]
        linkflags += [env['STATIC_FLAG']]

    # action
    program = env.Program(
        os.path.join(basedir, fullname),
        sources,
        CC=env['MPI_CC'],
        CXX=env['MPI_CXX'],
        CPPPATH=includes + [env['CPPPATH']] + [env['MPI_INCLUDE']],
        LIBPATH=libpath + [env['LIBPATH']] + [env['MPI_LIBDIR']],
        LIBS=libs + [env['LIBS']] + [env['MPI_LIB']],
        CXXFLAGS=cxxflags + [env['CXXFLAGS']],
        LINKFLAGS=linkflags + [env['LINKFLAGS']],
        LINK=env['MPI_LINKERFORPROGRAMS']
        )

    # alias
    alias = env.Alias(fullname, program)
    install = env.Install(binprefix, program)
    env.Alias(fullname, install)
    env.Default(alias)

# Add a program integrated in the Xmipp structure
def AddXmippProgram(name, libs=[], folder='programs'):
    finalLibPath = ['lib']
    finalIncludePath = ['libraries', '#']
    finalLibs = libs + ['XmippData', 'XmippExternal'] + FFTWLibs + SQLiteLibs + TIFFLibs
    if 'XmippRecons' in finalLibs and not 'XmippClassif' in finalLibs:
        finalLibs.append('XmippClassif')
    if int(env["arpack"]):
        finalLibs+=['arpack++','arpack','lapack','blas']
    program = AddProgram(name, 'applications/%s/%s' % (folder, name), '*.cpp', [],
        finalIncludePath, finalLibPath, finalLibs, [], [])
    env.Alias('xmipp_programs', program)
    return program
	
# Add a program integrated in the Xmipp structure
def AddXmippTest(name, testprog, command):
    #testprog = AddXmippProgram(name, ['gtest'], 'tests')
    testname = 'xmipp_' + name
    xmlFileName='applications/tests/OUTPUT/' + testname + ".xml"
    if  os.path.exists(xmlFileName):
       os.remove(xmlFileName)
    testcase = env.Alias('run_' + name , env.Command(xmlFileName,testname, command))
    env.Depends(testcase, testprog)
    test = env.Alias('run_tests', testcase)
    AlwaysBuild(testcase)
    return testcase


def AddXmippCTest(name):
    testprog = AddXmippProgram(name, ['gtest'], 'tests')
    AddXmippTest(name, testprog, "$SOURCE --gtest_output=xml:$TARGET")

def AddXmippPythonTest(name):
    print "Adding python test: ", name
    #FIXME ROB
    testprog = AddBatch(name, 'applications/tests/'+name, '.py')
    test = AddXmippTest(name, testprog, "$SOURCE $TARGET")
    return test


def AddXmippJavaTest(name):
    pass

    #env.Default(test)

def AddXmippMPIProgram(name, libs=[]):
    finalLibPath = ['lib']
    finalIncludePath = ['libraries', '#']
    finalLibs = libs + ['XmippData', 'XmippExternal', 'XmippParallel'] + FFTWLibs + SQLiteLibs + TIFFLibs
    if int(env["arpack"]):
        finalLibs+=['arpack++','arpack','lapack','blas']
    if 'XmippRecons' in finalLibs and not 'XmippClassif' in finalLibs:
        finalLibs.append('XmippClassif')
    for i in range(len(libs)):
       if libs[i] == 'XmippRecons':
          finalLibPath += ['libraries/reconstruction']
       elif libs[i] == 'XmippInterface':
          finalLibPath += ['libraries/interface']
       elif libs[i] == 'XmippRecons_Interface':
          finalLibPath += ['libraries/interface']
          finalLibs.insert(i + 1, 'XmippInterface')
       elif libs[i] == 'XmippReconsMPI':
          finalLibPath += ['libraries/reconstruction_mpi']
       elif libs[i] == 'XmippClassif':
          finalLibPath += ['libraries/classification']
    AddMPIProgram(name, 'applications/programs/' + name, '*.cpp', [],
        finalIncludePath, finalLibPath, finalLibs, [], [])

# For Roberto's new lib
def AddMPILibrary(name, basedir, sources, includes, libpath=[], libs=[]):
    # setup
    basedir = AddLastSlash(basedir)
    libprefix = os.path.join(env['prefix'], 'lib')
    #for x in sources:
    #    sources[sources.index(x)] = basedir + x

    # separate local and global includes
    for x in includes:
        if x[0] != '#':
            includes[includes.index(x)] = basedir + x

    # action
    # FIXME Exclusive may not be what users want
    if int(env['static']):
        library = env.StaticLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']] + [env['MPI_INCLUDE']],
            CC=env['MPI_CC'],
            CXX=env['MPI_CXX'],
            LIBPATH=[env['MPI_LIBDIR']] + libpath,
            LIBS=[env['MPI_LIB']] + libs
            )
    else:
        library = env.SharedLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']] + [env['MPI_INCLUDE']],
            CC=env['MPI_CC'],
            CXX=env['MPI_CXX'],
            LIBPATH=[env['MPI_LIBDIR']] + libpath,
            LIBS=[env['MPI_LIB']] + libs
            )

    # alias
    alias = env.Alias(name, library)
    install = env.Install(libprefix, library)
    env.Alias(name, install)
    env.Default(alias)

def AddLibrary(name, basedir, sources, includes, libpath=[], libs=[],
    shlibprefix='lib'):
    # setup
    basedir = AddLastSlash(basedir)
    libprefix = os.path.join(env['prefix'], 'lib')
    for x in sources:
        if x.find(basedir) == -1:
            sources[sources.index(x)] = basedir + x

    # separate local and global includes
    for x in includes:
        if x[0] != '#' and x[0] != '/':
            includes[includes.index(x)] = basedir + x

    # action
    # FIXME Exclusive may not be what users want
    # Sjors: Hack for OS X compilation (static libs, dynamic apps...??)
    if int(env['static']) or (env['PLATFORM'] == 'darwin'):
        library = env.StaticLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']],
            LIBPATH=libpath,
            LIBS=libs
            )
    else:
        library = env.SharedLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']],
            LIBPATH=libpath,
            LIBS=libs,
            SHLIBPREFIX=shlibprefix
            )

    install = env.Install(libprefix, library)
    alias = env.Alias(name, install)
    env.Default(alias)
    return alias

def AddJavaLibrary(name, basedir, srcdir):#, sourceList, includes, libpath=[], libs=[]):
    from os.path import join
    buildDir = join(basedir, 'classes', name)
    if not os.path.exists(buildDir): # create classes dir if not exists
        Execute(Mkdir(buildDir))
    if env['debug'] == True:
    	env['JAVAC'] = 'javac -g'
    buildClasses = env.Java(buildDir, join(basedir, srcdir), JAVAVERSION='1.6')
    env.Depends(buildClasses, env.Alias('javaEnums'))
    jarfile = join(basedir, '..', name + '.jar')
    buildJar = env.Jar(target=jarfile, source=buildClasses, JARCHDIR=buildDir)
    alias = env.Alias(name, buildJar)
    env.Default(alias)
    return alias

def removeAll(basedir, regexp):
	import glob

	files = glob.glob(basedir + regexp)
	for i in range(len(files)):
		os.remove(files[i])

def AddJavaApp(name, appDir, outDir):
    import shutil
    sourceDir = os.path.join(appDir, 'src')
    resourcesDir = os.path.join(sourceDir, 'resources')
    libsDir = os.path.join(appDir ,'libs')
    metainfDir = os.path.join(sourceDir, 'META-INF')
    buildDir = os.path.join(appDir ,'build')
    buildResourcesDir = os.path.join(buildDir, 'resources')
    buildMetainf = os.path.join(buildDir, 'META-INF')
    outLibsDir = os.path.join(outDir, 'libs')
    # Clears "buildDir"
    if not os.path.exists(buildDir):
        os.mkdir(buildDir)
        #os.mkdir(buildResourcesDir)

    env.Append(JAVACLASSPATH=os.path.join(libsDir, '*'))
    buildClasses = env.Java(buildDir, sourceDir, JAVAVERSION='1.6')
    # Copies MANIFEST
    copyMetainf = env.Install(buildMetainf, Glob(metainfDir, "MANIFEST.MF", []))
    buildJar = env.Jar(os.path.join(outDir, name + '.jar'), buildDir, JARCHDIR=buildDir)

    appLibs = {}
    jarList = Glob(libsDir, "*.jar", [])
    for l in jarList:
        lname = os.path.basename(l)
        if not appLibs.has_key(lname):
            install = env.Install(outLibsDir, l)
            appLibs[lname] = install
        env.Depends(buildClasses, appLibs[lname])

    copyPluginResources = env.Install(buildResourcesDir, Glob(resourcesDir, "*?.???", []))
    env.Depends(buildJar, [copyMetainf, copyPluginResources, buildClasses])
    pluginAlias = env.Alias(name, buildJar)
    env.Depends(buildClasses, copyJar)

    return pluginAlias

def AddImageJPlugin(name, pluginDir, outDir, requiredPlugins=[]):
    import shutil
    sourceDir = os.path.join(pluginDir, 'src')
    resourcesDir = os.path.join(sourceDir, 'resources')
    libsDir = os.path.join(pluginDir ,'libs')
    macrosDir = os.path.join(pluginDir ,'macros')
    buildDir = os.path.join(pluginDir ,'build')
    buildResourcesDir = os.path.join(buildDir, 'resources')
    # Clears "buildDir"
    if not os.path.exists(buildDir):
        os.mkdir(buildDir)
        os.mkdir(buildResourcesDir)
    # Copies 'plugins.config' to build dir...
    buildClasses = env.Java(buildDir, sourceDir, JAVAVERSION='1.6')
    env.Depends(buildClasses, requiredPlugins)
    copyPluginConfig = env.Install(buildDir, os.path.join(sourceDir, 'plugins.config'))#Glob(sourceDir, 'plugins.config', []))
    buildJar = env.Jar(os.path.join(outDir, name + '.jar'), buildDir, JARCHDIR=buildDir)

    jarList = Glob(libsDir, "*.jar", [])
    for l in jarList:
        lname = os.path.basename(l)
        if not PluginLibs.has_key(lname):
            install = env.Install(outDir, l)
            PluginLibs[lname] = install
        env.Depends(buildClasses, PluginLibs[lname])

    copyPluginResources = env.Install(buildResourcesDir, Glob(resourcesDir, "*?.???", []))
    env.Depends(buildJar, [copyPluginConfig, copyPluginResources, buildClasses])
    pluginAlias = env.Alias(name, buildJar)
    env.Depends(buildClasses, copyJar)

    outMacrosDir = os.path.join(outDir, "..", "macros")
    env.Alias('copyMacros', env.Install(outMacrosDir, Glob(macrosDir, "*?.???", [])))
    return pluginAlias

# Gtest
if int(env['gtest']):
    DataSources = Glob('external/gtest-1.6.0/fused-src/gtest', 'gtest-all.cc', [])
    AddLibrary('gtest', 'external/gtest-1.6.0/fused-src/gtest', DataSources, ['#'],
               [], [])

# Bilib
BilibSources = Glob('external/bilib/sources', '*.cc', [])

# INRIA
INRIASources = Glob('external/inria', '*.cc', [])

# Condor
CondorSources = Glob('external/condor', '*.cpp', [])

AddLibrary('XmippExternal', 'external',
   INRIASources + BilibSources + CondorSources,
   ['bilib', 'bilib/headers', 'bilib/types'])

# XmippData
DataSources = Glob('libraries/data', '*.cpp', [])
AddLibrary('XmippData', 'libraries/data', DataSources, ['#'],
           ['lib'], ['XmippExternal'] + FFTWLibs + TIFFLibs + SQLiteLibs)

#Xmipp Python Extension
PyExtSources = Glob('libraries/bindings/python', '*.cpp', [])
#import distutils.sysconfig
pythonIncludes = ["#" +os.path.join(PythonDir,dir) for dir in [".","Include"]]
pythonbinding = AddLibrary('xmipp', 'libraries/bindings/python', PyExtSources,
           ['#libraries', "#"] + pythonIncludes,
           ['lib'], ['XmippData', 'XmippRecons'], '')

# Reconstruction
ReconsSources = [
    'adjust_volume_grey_levels.cpp',
    'align2d.cpp',
    'align_tilt_pairs.cpp',
    'angular_commonline.cpp',
    'angular_continuous_assign.cpp',
    'angular_discrete_assign.cpp',
    'angular_distance.cpp',
    'angular_neighbourhood.cpp',
    'angular_projection_matching.cpp',
    'angular_class_average.cpp',
    'angular_project_library.cpp',
    'art_crystal.cpp',
    'art_xray.cpp',
    'base_art_recons.cpp',
    'basic_art.cpp',
    'classify_compare_classes.cpp',
    'classify_evaluate_classes.cpp',
    'ctf_correct_wiener3d.cpp',
    'ctf_correct_idr.cpp',
    'ctf_enhance_psd.cpp',
    'ctf_estimate_from_micrograph.cpp',
    'ctf_estimate_from_psd.cpp',
    'ctf_estimate_psd_with_arma.cpp',
    'ctf_group.cpp',
    'ctf_phase_flip.cpp',
    'ctf_sort_psds.cpp',
    'denoise.cpp',
    'directions.cpp',
    'fourier_filter.cpp',
    'image_rotational_spectra.cpp',
    'image_sort_by_statistics.cpp',
    'micrograph_automatic_picking.cpp',
    'micrograph_automatic_picking_for_qt.cpp',
    'ml_align2d.cpp',
###    'ml_align3d.cpp',
    'mean_shift.cpp',
    'mlf_align2d.cpp',
    'ml_refine3d.cpp',
    'ml_tomo.cpp',
    'ml2d.cpp',
    'nma_alignment.cpp',
    'pdb_nma_deform.cpp',
    'phantom_simulate_microscope.cpp',
    'precompute_sampling.cpp',
    'program_extension.cpp',
    'program_filter.cpp',
    'project.cpp',
    'project_crystal.cpp',
    'project_real_shears.cpp',
    'project_XR.cpp',
    'projectTomography.cpp',
    'radon.cpp',
    'recons_misc.cpp',
    'reconstruct_art.cpp',
    'reconstruct_art_pseudo.cpp',
    'reconstruct_fourier.cpp',
    'reconstruct_wbp.cpp',
    'refinement.cpp',
    'resolution_ibw.cpp',
    'resolution_ssnr.cpp',
    'symmetrize.cpp',
    'threshold.cpp',
    'tomo_align_dual_tilt_series.cpp',
    'tomo_align_tilt_series.cpp',
    'tomo_align_refinement.cpp',
    'tomo_detect_missing_wedge.cpp',
    'tomo_remove_fluctuations.cpp',
    'tomo_extract_subvolume.cpp',
    'transform_downsample.cpp',
    'transform_geometry.cpp',
    'volume_correct_bfactor.cpp',
    'volume_enhance_contrast.cpp',
    'volume_from_pdb.cpp',
    'volume_segment.cpp',
    'volume_to_pseudoatoms.cpp',
    'xray_import.cpp'
]
ReconsDependLibraries =['XmippExternal', 'XmippData', 'pthread','XmippClassif']
if int(env['arpack']):
    ReconsSources.append("angular_gcar.cpp")
    ReconsDependLibraries+=['arpack','lapack','blas']

AddLibrary('XmippRecons', 'libraries/reconstruction', ReconsSources,
           ['#libraries', '#external', '#'], ['lib'], ReconsDependLibraries)

# Classification
ClassificationSources = Glob('libraries/classification', '*.cpp', [])
AddLibrary('XmippClassif', 'libraries/classification', ClassificationSources,
    ['#libraries', '#'], ['lib'], ['XmippExternal', 'XmippData'])

# XmippParallel
if int(env['mpi']):
    ParallelSources = Glob('libraries/parallel', '*.cpp', []);
    AddMPILibrary("XmippParallel", 'libraries/parallel', ParallelSources, ["#", "#libraries", "#external"],
              ['lib'], ['XmippExternal', 'XmippData', 'XmippRecons', 'XmippClassif'] + FFTWLibs + TIFFLibs + SQLiteLibs)

# Interface
InterfaceSources = Glob('libraries/interface', '*.cpp', [])
AddLibrary('XmippInterface', 'libraries/interface', InterfaceSources,
    ['#libraries', '#external', '#'], ['lib'], ['XmippExternal', 'XmippData', 'pthread'])

# Recons Interface
#AddLibrary('XmippRecons_Interface', '#libraries/reconstruction',
#           ReconsInterfaceSources, ['#libraries', '#external', '#'],['lib'],['XmippExternal','XmippData','XmippRecons','XmippInterface'])

def WriteJavaEnum(class_name, header_file, pattern, log):
    java_file = "libraries/bindings/java/xmipp/%s.java" % class_name
    env.Depends(java_file, header_file)
    f = open(header_file)
    fOut = open(java_file, 'w+')
    counter = 0;
    last_label_pattern = pattern + "LAST_LABEL"
    fOut.write("package xmipp; \n")
    fOut.write("public class " + class_name + " {\n")

    for line in f:
        l = line.strip();
        if l.startswith(pattern):
            if '///' in l:
                l, comment = l.split('///')
            else:
                comment = ''
            if l.startswith(last_label_pattern):
                l = l.replace(last_label_pattern, last_label_pattern + " = " + str(counter) + ";")
            if (l.find("=") == -1):
                l = l.replace(",", " = %d;" % counter)
                counter = counter + 1;
            else:
                l = l.replace(",", ";")

            fOut.write("   public static final int %s ///%s\n" % (l, comment))
    fOut.write("}\n")
    fOut.close()
    f.close()
    # Write log file
    if log:
        from datetime import datetime
        d = str(datetime.now())
        #d = date.today();
        log.write("Java file '%s' successful generated at %s\n" % (java_file, d))

def ExtractEnumFromHeader(source, target, env):
    # this is very ugly, we still need more scons knowledge

    log = open(str(target[0]), 'w+')
    for (class_name, list) in javaEnumDict.iteritems():
        WriteJavaEnum(class_name, list[0], list[1], log)

    log.close()
    return None

# ImageJ plugins.
# Installs jvm
if int(env['java']):
    # Update enums from c++ headers, if not exist, generate it
    for (class_name, list) in javaEnumDict.iteritems():
       java_file = "libraries/bindings/java/xmipp/%s.java" % class_name
       if not os.path.exists(java_file):
          WriteJavaEnum(class_name, list[0], list[1], None)

    env.Alias('javaEnums', env.Command("libraries/bindings/java/xmipp/enums.changelog",
                            ["libraries/data/xmipp_image_base.h","libraries/data/metadata_label.h" ], ExtractEnumFromHeader))
    JavaInterfaceSources = Glob('libraries/bindings/java', '*.cpp', [])
    JavaDependLibraries=['XmippData', 'pthread', 'XmippRecons', 'XmippClassif']
    if int(env['arpack']):
        JavaDependLibraries+=['arpack++','arpack','lapack','blas']
    javaJni = AddLibrary('XmippJavaInterface', 'libraries/bindings/java', JavaInterfaceSources,
    ['#libraries', '#external', '#']+env['JNI_CPPPATH'], ['lib'],JavaDependLibraries)

    env.Append(JAVACLASSPATH='external/imagej/ij.jar:external/imagej/plugins/*:libraries/bindings/java/*')
    env['ENV']['LANG'] = 'en_GB.UTF-8'
    env['JARFLAGS'] = '-Mcf'    # Default "cf". "M" = Do not add a manifest file.

    # Xmipp interface is needed by plugins.
    javaLib = AddJavaLibrary('XmippJavaInterface', 'libraries/bindings/java/src', 'xmipp')#, ['#'],
    lib2 = AddJavaLibrary('XmippIJInterface', 'libraries/bindings/java/src', 'xmippij')
    env.Depends(lib2, javaLib)
    # Copies jar file to ImageJ plugins folder (plugins below will look for it there).
    copyJar = env.InstallAs(target='external/imagej/plugins/XmippJavaInterface.jar',
              source='libraries/bindings/java/XmippJavaInterface.jar')
    # ImageJ plugins.
    javaPlugins = []
    javaPlugins.append(AddImageJPlugin('Xmipp_IO', 'libraries/graphicsj/Xmipp_IO', 'external/imagej/plugins'))
    javaPlugins.append(AddImageJPlugin('Xmipp_Projections_Explorer', 'libraries/graphicsj/Xmipp_Projections_Explorer', 'external/imagej/plugins'))
    jbrowser = AddImageJPlugin('Xmipp_Browser', 'libraries/graphicsj/Xmipp_Browser', 'external/imagej/plugins')
    javaPlugins.append(jbrowser)
    #javaPlugins.append(AddImageJPlugin('Xmipp_MetaData_Browser', 'libraries/graphicsj/Xmipp_MetaData_Browser', 'external/imagej/plugins'))
    #env.Depends('Xmipp_MetaData_Browser', 'Xmipp_Browser')
    javaPlugins.append(AddImageJPlugin('Masks_ToolBar', 'libraries/graphicsj/Masks_ToolBar', 'external/imagej/plugins'))
    javaPlugins.append(AddImageJPlugin('Xmipp_Tomo', 'libraries/graphicsj/Xmipp_Tomo', 'external/imagej/plugins'))
    javaPlugins.append(AddJavaApp('XmippPP_', 'libraries/graphicsj/Xmipp_Particle_Picker', 'external/Xmipp_Particle_Picker'))
    # Java apps
    #javaPlugins.append(AddJavaApp('Java3DInstaller', 'libraries/graphicsj/Java3DInstaller', 'external/Java3DInstaller'))
    javaPlugins.append(AddJavaApp('Stitching', 'libraries/graphicsj/Stitching', 'external/Stitching'))

    import sys
    sys.path.append("external/scons/ToolsFromWiki")
    import install
    install.TOOL_INSTALL(env)
    javaExtPlugins = env.InstallFiles('external/imagej/plugins', 'libraries/graphicsj/plugins', exclude='.svn')
    javaAlias = env.Alias('java', [javaJni, javaLib, copyJar, javaExtPlugins, env.Alias('copyMacros')] + javaPlugins)
    env.Default(javaAlias)

# --- Programs

# Src (apps)

AddXmippProgram('angular_class_average', ['XmippRecons'])
AddXmippProgram('angular_commonline', ['XmippRecons'])
AddXmippProgram('angular_continuous_assign', ['XmippRecons'])
AddXmippProgram('angular_discrete_assign', ['XmippRecons'])
AddXmippProgram('angular_distance', ['XmippRecons'])
AddXmippProgram('angular_distribution_show', ['XmippInterface'])
AddXmippProgram('angular_neighbourhood', ['XmippRecons'])
AddXmippProgram('angular_projection_matching', ['XmippRecons'])
AddXmippProgram('angular_project_library', ['XmippRecons'])
AddXmippProgram('angular_rotate')
AddXmippProgram('classify_analyze_cluster', ['XmippClassif'])
AddXmippProgram('classify_compare_classes', ['XmippRecons'])
AddXmippProgram('classify_evaluate_classes', ['XmippRecons'])
AddXmippProgram('classify_kerdensom', ['XmippClassif'])
AddXmippProgram('ctf_correct_wiener3d', ['XmippRecons'])
AddXmippProgram('ctf_correct_idr', ['XmippRecons'])
AddXmippProgram('ctf_create_ctfdat', ['XmippRecons'])
AddXmippProgram('ctf_enhance_psd', ['XmippRecons'])
AddXmippProgram('ctf_estimate_from_micrograph', ['XmippRecons'])
AddXmippProgram('ctf_estimate_from_psd', ['XmippRecons'])
AddXmippProgram('ctf_group', ['XmippRecons'])
AddXmippProgram('ctf_phase_flip', ['XmippRecons'])
AddXmippProgram('ctf_sort_psds', ['XmippRecons'])
#AddXmippProgram('denoise', ['XmippRecons'])
AddXmippProgram('image_align', ['XmippRecons'])
AddXmippProgram('image_align_tilt_pairs', ['XmippRecons'])
AddXmippProgram('image_convert')
AddXmippProgram('image_find_center')
AddXmippProgram('image_header')
AddXmippProgram('image_histogram')
AddXmippProgram('image_operate')
AddXmippProgram('image_rotational_spectra', ['XmippRecons'])
AddXmippProgram('image_sort_by_statistics', ['XmippRecons'])
AddXmippProgram('image_separate_objects')
AddXmippProgram('image_statistics')
AddXmippProgram('image_vectorize')
#AddXmippProgram('mean_shift')
AddXmippProgram('metadata_convert_to_spider', ['XmippInterface'])
AddXmippProgram('metadata_histogram')
AddXmippProgram('metadata_import')
AddXmippProgram('metadata_split')
AddXmippProgram('metadata_utilities')
AddXmippProgram('micrograph_scissor'),
AddXmippProgram('micrograph_automatic_picking',['XmippRecons'])
AddXmippProgram('ml_align2d', ['XmippRecons'])
AddXmippProgram('mlf_align2d', ['XmippRecons'])
AddXmippProgram('ml_refine3d', ['XmippRecons'])
AddXmippProgram('mlf_refine3d', ['XmippRecons'])
AddXmippProgram('ml_tomo', ['XmippRecons'])
AddXmippProgram('mrc_create_metadata')
AddXmippProgram('nma_alignment', ['XmippRecons'])
AddXmippProgram('pdb_nma_deform', ['XmippRecons'])
AddXmippProgram('phantom_create', ['XmippRecons'])
AddXmippProgram('phantom_project', ['XmippRecons', 'XmippInterface'])
AddXmippProgram('phantom_simulate_microscope', ['XmippRecons'])
# AddXmippProgram('phantom_transform', ['XmippRecons', 'XmippInterface'])
#Sjors: note that crystal stuff in ART is not working yet....
AddXmippProgram('reconstruct_art', ['XmippRecons'])
AddXmippProgram('reconstruct_art_pseudo', ['XmippRecons'])
AddXmippProgram('reconstruct_wbp', ['XmippRecons'])
AddXmippProgram('reconstruct_fourier', ['XmippRecons'])
AddXmippProgram('resolution_fsc')
AddXmippProgram('resolution_ibw', ['XmippRecons'])
AddXmippProgram('resolution_ssnr', ['XmippRecons'])
AddXmippProgram('transform_add_noise')
AddXmippProgram('transform_adjust_volume_grey_levels', ['XmippRecons'])
AddXmippProgram('transform_center_image')
AddXmippProgram('transform_downsample', ['XmippRecons'])
AddXmippProgram('transform_filter', ['XmippRecons'])
AddXmippProgram('transform_geometry', ['XmippRecons'])
AddXmippProgram('transform_mask')
AddXmippProgram('transform_mirror')
AddXmippProgram('transform_morphology')
AddXmippProgram('transform_normalize')
AddXmippProgram('transform_range_adjust')
AddXmippProgram('transform_symmetrize', ['XmippRecons'])
AddXmippProgram('transform_threshold', ['XmippRecons'])
AddXmippProgram('transform_window')
#AddXmippProgram('test_program', ['XmippRecons'])
#AddXmippProgram('test_sql')
AddXmippProgram('template_threads')
AddXmippProgram('tomo_align_dual_tilt_series', ['XmippRecons'])
AddXmippProgram('tomo_align_refinement', ['XmippRecons'])
AddXmippProgram('tomo_align_tilt_series', ['XmippRecons'])
AddXmippProgram('tomo_detect_missing_wedge', ['XmippRecons'])
AddXmippProgram('tomo_project', ['XmippRecons'])
AddXmippProgram('tomo_remove_fluctuations', ['XmippRecons'])
AddXmippProgram('tomo_extract_subvolume', ['XmippRecons'])
AddXmippProgram('volume_align')
AddXmippProgram('volume_center')
AddXmippProgram('volume_correct_bfactor', ['XmippRecons'])
AddXmippProgram('volume_enhance_contrast', ['XmippRecons'])
AddXmippProgram('volume_find_symmetry')
AddXmippProgram('volume_from_pdb', ['XmippRecons'])
AddXmippProgram('volume_reslice')
AddXmippProgram('volume_segment', ['XmippRecons'])
AddXmippProgram('volume_to_pseudoatoms', ['XmippRecons'])
AddXmippProgram('xray_import', ['XmippRecons'])
AddXmippProgram('xray_psf_create')
AddXmippProgram('xray_project', ['XmippRecons'])

if int(env['arpack']):
    AddXmippProgram('angular_gcar', ['XmippRecons'])


# --- Scripts

# Batches (apps)
#
AddBatch('apropos', 'applications/scripts/apropos', '.py')
AddBatch('metadata_selfile_create', 'applications/scripts/metadata_selfile_create', '.py')
AddBatch('metadata_show', 'applications/scripts/metadata_show', '.py')
#AddBatch('metadata_operate', 'applications/scripts/metadata_operate','.py')
protocols_main = AddBatch('protocols', 'protocols', '.py')
env.Alias('protocols', protocols_main)
AddBatch('showj', 'applications/scripts/showj', '.py')
AddBatch('micrograph_particle_picking', 'applications/scripts/micrograph_particle_picking', '.py')
AddBatch('micrograph_tiltpair_picking', 'applications/scripts/micrograph_tiltpair_picking', '.py')
AddBatch('projections_explorerj', 'applications/scripts/projections_explorerj', '.py')
AddBatch('tomoj', 'applications/scripts/tomoj', '.py')
AddBatch('visualize_preprocessing_micrographj', 'applications/scripts/visualize_preprocessing_micrograph', '.py')
#AddBatch('browserj', 'applications/scripts/browserj', '.py')
AddBatch('browser', 'applications/scripts/browser', '.py')
AddBatch('rot_spectraj', 'applications/scripts/rot_spectraj', '.py')
#AddBatch('metadata_showj', 'applications/scripts/metadata_showj', '.py')
AddBatch('stitchingj', 'applications/scripts/stitchingj', '.py')
AddBatch('mpi_steps_runner', 'protocols', '.py')
AddBatch('viewer', 'applications/scripts/viewer', '.py')

# MPI
if int(env['mpi']):
    AddXmippMPIProgram('mpi_angular_class_average', ['XmippRecons'])
    AddXmippMPIProgram('mpi_angular_continuous_assign', ['XmippRecons'])
    AddXmippMPIProgram('mpi_angular_gcar_commonlines', ['XmippRecons'])
    AddXmippMPIProgram('mpi_angular_projection_matching', ['XmippRecons'])
    AddXmippMPIProgram('mpi_angular_project_library', ['XmippRecons'])
    AddXmippMPIProgram('mpi_classify_CL2D', ['XmippRecons'])
    AddXmippMPIProgram('mpi_classify_CL2D_core_analysis', ['XmippRecons'])
    AddProgramLink('classify_CL2D','mpi_classify_CL2D')
    AddXmippMPIProgram('mpi_ctf_correct_idr', ['XmippRecons'])
    AddXmippMPIProgram('mpi_image_operate')
    AddXmippMPIProgram('mpi_image_rotational_pca', ['XmippRecons'])
    AddXmippMPIProgram('mpi_performance_test', ['XmippRecons'])
    AddXmippMPIProgram('mpi_image_sort', ['XmippRecons'])
    AddProgramLink('image_sort','mpi_image_sort')
    AddXmippMPIProgram('mpi_ml_align2d', ['XmippRecons'])
    AddXmippMPIProgram('mpi_ml_tomo', ['XmippRecons'])
    AddXmippMPIProgram('mpi_mlf_align2d', ['XmippRecons'])
    AddXmippMPIProgram('mpi_ml_refine3d', ['XmippRecons'])
    AddXmippMPIProgram('mpi_mlf_refine3d', ['XmippRecons'])
    AddXmippMPIProgram('mpi_nma_alignment', ['XmippRecons'])
    AddXmippMPIProgram('mpi_xray_project', ['XmippRecons'])
    AddXmippMPIProgram('mpi_reconstruct_art', ['XmippRecons'])
    AddXmippMPIProgram('mpi_reconstruct_wbp', ['XmippRecons'])
    AddXmippMPIProgram('mpi_reconstruct_fourier', ['XmippRecons'])
    AddXmippMPIProgram('mpi_run', ['XmippRecons'])
    AddXmippMPIProgram('mpi_tomo_extract_subvolume', ['XmippRecons'])
    AddXmippMPIProgram('mpi_transform_filter', ['XmippRecons'])
    AddXmippMPIProgram('mpi_transform_symmetrize', ['XmippRecons'])
    AddXmippMPIProgram('mpi_transform_geometry', ['XmippRecons'])
    AddXmippMPIProgram('mpi_transform_mask', ['XmippRecons'])
    AddXmippMPIProgram('mpi_transform_normalize', ['XmippRecons'])
#    AddXmippMPIProgram('template_threads', ['XmippRecons'])
#    AddXmippMPIProgram('template_mpi', ['XmippRecons'])

#---- Tests
if int(env['gtest']):
     AddXmippCTest('test_fftw')
     AddXmippCTest('test_filters')
     AddXmippCTest('test_funcs')
     AddXmippCTest('test_image')
     AddXmippCTest('test_image_generic')
     AddXmippCTest('test_matrix')
     AddXmippCTest('test_metadata')
     AddXmippCTest('test_multidim')
     AddXmippCTest('test_polar')
     AddXmippCTest('test_sampling')
     AddXmippCTest('test_transformation')
     #env.Depends('run_tests', [fftw, tiff, sqlite])
     #python tests
     test = AddXmippPythonTest('test_pythoninterface')
     AddXmippPythonTest('test_projectionmatching')
     AddXmippPythonTest('test_pysqlite')
     env.Depends(test, pythonbinding)
     env.Depends('run_tests', 'xmipp_programs')
     #env.Default('run_tests'     )
# QT
if int(env['qt']):
    envQT = env.Clone()

    if int(env['QT4']):
        # FIXME see SConstruct
        env['QTDIR'] = ''
        env['QT_LIB'] = ''

        envQT.Tool('qt4')
        envQT.EnableQt4Modules(['QtCore', 'QtGui', 'Qt3Support'], debug=False)

        # Fix for moc and #ifdefs (qt3 uses MOC_SKIP_*)
        envQT['QT4_MOCFROMHFLAGS'] += ['-DQT3_SUPPORT']
        envQT['QT4_MOCFROMCXXFLAGS'] += ['-DQT3_SUPPORT']

    else:
        envQT.Tool('qt')

        # QT_AUTOSCAN does not work because .h and .cpp are not in the same dir
        # envQT.SetDefault(QT_AUTOSCAN = 1)

        # Once again, just in case, Copy() does not work too well
        envQT.Replace(QT_LIB=env['QT_LIB'])

    def AddQtProgram(name, basedir, sources_pattern='*.cpp', skip_list=[],
        mocs=[], includes=[], libpath=[], libs=[], cxxflags=[],
        linkflags=[]):

        # setup
        basedir = AddLastSlash(basedir)
        fullname = env['prepend'] + name
        binprefix = os.path.join(env['prefix'], 'bin')

        extra = []

        if int(env['QT4']):
            for i in mocs:
                extra.append(envQT.Moc4(basedir + i))
        else:
            for i in mocs:
                extra.append(envQT.Moc(basedir + i))

        sources = Glob(basedir, sources_pattern, skip_list)

        program = envQT.Program(
            basedir + env['prepend'] + name,
            sources + extra,
            CPPPATH=envQT['CPPPATH'] + includes + [env['CPPPATH']],
            LIBPATH=envQT['LIBPATH'] + libpath + [env['LIBPATH']],
            LIBS=envQT['LIBS'] + libs + [env['LIBS']] + TIFFLibs,
            CXXFLAGS=cxxflags + [env['CXXFLAGS']],
            LINKFLAGS=linkflags + [env['LINKFLAGS']],
            LINK=env['LINKERFORPROGRAMS']
            )

        # alias
        alias = env.Alias(fullname, program)
        install = env.Install(binprefix, program)
        env.Alias(fullname, install)
        env.Default(alias)

    # FIXME an AddQtLibrary function does not worth the cost, right?
    graphics_name = 'XmippGraphics'
    graphics_basedir = AddLastSlash('libraries/graphics')

    graphics_sources = Glob(graphics_basedir, '*.cpp', [])
    graphics_cpppath = envQT['CPPPATH'] + ['libraries', '#']

    graphics_objects = []
    for i in graphics_sources:
        graphics_objects.append(i)

    if int(env['static']):
        graphics = envQT.StaticLibrary(
            graphics_basedir + graphics_name,
            graphics_objects,
            CPPPATH=graphics_cpppath
            )
    else:
        graphics = envQT.SharedLibrary(
            graphics_basedir + graphics_name,
            graphics_objects,
            CPPPATH=graphics_cpppath
            )

    graphics_alias = env.Alias(graphics_name, graphics)
    graphics_install = env.Install(os.path.join(env['prefix'], 'lib'),
        graphics)
    env.Alias(graphics_name, graphics_install)
    env.Default(graphics_alias)

    # Add a program integrated in the Xmipp structure
    def AddXmippQtProgram(name, mocs=[], libs=[]):
        finalLibPath = ['lib']
        finalIncludePath = ['libraries', '#']
        finalLibs = ['XmippData', 'XmippExternal', 'XmippGraphics',
            'XmippRecons', 'XmippClassif'] + FFTWLibs + SQLiteLibs + libs
        if int(env["arpack"]):
            finalLibs+=['arpack++','arpack','lapack','blas']
        for i in range(len(libs)):
           if libs[i] == 'XmippInterface':
    	      finalLibPath += ['libraries/interface']
           elif libs[i] == 'XmippRecons_Interface':
    	      finalLibPath += ['libraries/interface']
              finalLibs += ['XmippInterface']
        AddQtProgram(name, 'applications/programs/' + name, '*.cpp', [], mocs,
    	    finalIncludePath, finalLibPath, finalLibs, [], [])

    AddXmippQtProgram('micrograph_mark', ['popup_menu_mark.h'])
    AddXmippQtProgram('show', [], ['XmippClassif', 'XmippRecons'])

if int(env['matlab']):
    import os

    def AddMatlabBinding(name):
        print 'compiling Matlab wrapper for ' + name
        command = env['MATLAB_DIR'] + '/bin/mex -O -outdir libraries/bindings/matlab -I. -Ilibraries/data -Ilibraries -Llib -Ilibraries/reconstruction -lXmippRecons -lXmippData -lXmippExternal libraries/bindings/matlab/tom_xmipp_' + name + '_wrapper.cpp'
        output = os.popen(command).read()
        if len(output) > 0:
            print output

    bindings = ['adjust_ctf', 'align2d', 'ctf_correct_phase',
        'mask', 'mirror', 'morphology', 'normalize', 'psd_enhance',
        'resolution', 'rotate', 'scale', 'scale_pyramid', 'volume_segment']

    for i in range(len(bindings)):
       AddMatlabBinding(bindings[i])

# Clean
# Configuration or cleaning
if env.GetOption('clean'):
    print '* Cleaning  ...'
    os.system("( cd external/fftw-3.2.2    ; make clean >& /dev/null )");
    os.system("( cd external/sqlite-3.6.23 ; make clean >& /dev/null )");
