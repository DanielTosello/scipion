#!/usr/bin/env python

Import('env')

# Required for custom functions
import os

FFTWDir = "external/fftw-3.2.2"
FFTWLibs = ['fftw3', 'fftw3_threads']
TIFFDir = "external/tiff-3.9.4"
TIFFLibs = ['tiff']
SQliteDir = "external/sqlite-3.6.23"
SQLiteLibs = ['sqlite3']
PYSQliteDir = "external/pysqlite-2.6.3"

PluginLibs = {}
PluginResources = {}
javaEnumDict = {'ImageWriteMode': ['libraries/data/image_base.h', 'WRITE_'], 
            'CastWriteMode': ['libraries/data/image_base.h', 'CW_'], 
            'MDLabel': ['libraries/data/metadata_label.h', 'MDL_']}
javaEnumFiles = []
headerEnumFiles = []

copyJar = None


def AddMatchingFiles((pattern, blacklist, sources), directory, files):
    ''' Callback, adds all matching files in dir '''
    import fnmatch
    for file in fnmatch.filter(files, pattern):
        if file not in blacklist:
           # DBG print 'Adding ' + os.path.join(directory, file)
           sources.append(os.path.join(directory, file))

def Glob(dir, pattern, blacklist):
    ''' Custom made globbing '''
    import os
    sources = []
    os.path.walk(dir, AddMatchingFiles, (pattern, blacklist, sources))
    return sources

def AddLastSlash(string):
    ''' Low trick for correct parsing of paths '''
    str = string.strip();
    if len(str) == 0:
        return "";
    if not str.endswith('/'):
        str = str + '/'
    return str

def AddBatch(name, basedir, extension=''):
    # setup
    basedir = AddLastSlash(basedir)
    fullname = env['prepend'] + name
    binprefix = os.path.join(env['prefix'], 'bin')

    # action
    command = env.Command(os.path.join(basedir, fullname),
        os.path.join(basedir, 'batch_' + name + extension), [Copy('$TARGET',
        '$SOURCE'), Chmod('$TARGET', 0755)])

    # alias
    alias = env.Alias(fullname, command)
    install = env.Install(binprefix, command)
    env.Alias(fullname, install)
    env.Default(alias)

def AddProtocol(name, basedir):
    # setup
    basedir = AddLastSlash(basedir)
    binprefix = os.path.join(env['prefix'], 'protocols')

    # only add prefix to protocol_*
    if name.find('protocol') < 0:
            install = env.Install(binprefix, basedir + name)
            env.Default(install)

    else:
        fullname = env['prepend'] + name

        # action
        command = env.Command(os.path.join(basedir, fullname),
            os.path.join(basedir, name), [Copy('$TARGET',
            '$SOURCE'), Chmod('$TARGET', 0755)])


        # alias
        alias = env.Alias(fullname, command)
        install = env.Install(binprefix, command)
        env.Alias(fullname, install)
        env.Default(alias)

def AddProgram(name, basedir, sources_pattern='*.cpp', skip_list=[],
               includes=[], libpath=[], libs=[], cxxflags=[],
               linkflags=[]):
    ''' add a new program to the build list '''
    # setup
    basedir = AddLastSlash(basedir)
    fullname = env['prepend'] + name
    sources = Glob(basedir, sources_pattern, skip_list)
    binprefix = os.path.join(env['prefix'], 'bin')

    # FIXME fix for static executables
    if env['static']:
        cxxflags += [env['STATIC_FLAG']]
        linkflags += [env['STATIC_FLAG']]

    # action
    program = env.Program(
        os.path.join(basedir, fullname),
        sources,
        CPPPATH=includes + [env['CPPPATH']],
        LIBPATH=libpath + [env['LIBPATH']],
        LIBS=libs + [env['LIBS']],
        CXXFLAGS=cxxflags + [env['CXXFLAGS']],
        LINKFLAGS=linkflags + [env['LINKFLAGS']],
        LINK=env['LINKERFORPROGRAMS']
        )

    install = env.Install(binprefix, program)
    alias = env.Alias(fullname, install)
    env.Default(alias)
    return alias

def AddMPIProgram(name, basedir, sources_pattern='*.cpp', skip_list=[],
                  includes=[], libpath=[], libs=[], cxxflags=[],
                  linkflags=[]):

    # setup
    basedir = AddLastSlash(basedir)
    fullname = env['prepend'] + name
    sources = Glob(basedir, sources_pattern, skip_list)
    binprefix = os.path.join(env['prefix'], 'bin')

    # FIXME fix for static executables
    if env['static']:
        cxxflags += [env['STATIC_FLAG']]
        linkflags += [env['STATIC_FLAG']]

    # action
    program = env.Program(
        os.path.join(basedir, fullname),
        sources,
        CC=env['MPI_CC'],
        CXX=env['MPI_CXX'],
        CPPPATH=includes + [env['CPPPATH']] + [env['MPI_INCLUDE']],
        LIBPATH=libpath + [env['LIBPATH']] + [env['MPI_LIBDIR']],
        LIBS=libs + [env['LIBS']] + [env['MPI_LIB']],
        CXXFLAGS=cxxflags + [env['CXXFLAGS']],
        LINKFLAGS=linkflags + [env['LINKFLAGS']],
        LINK=env['MPI_LINKERFORPROGRAMS']
        )

    # alias
    alias = env.Alias(fullname, program)
    install = env.Install(binprefix, program)
    env.Alias(fullname, install)
    env.Default(alias)

# Add a program integrated in the Xmipp structure
def AddXmippProgram(name, libs=[], folder='programs'):
    finalLibPath = ['lib']
    finalIncludePath = ['libraries', '#']
    finalLibs = libs + ['XmippData', 'XmippExternal'] + FFTWLibs + SQLiteLibs + TIFFLibs
    return AddProgram(name, 'applications/%s/%s' % (folder, name), '*.cpp', [],
        finalIncludePath, finalLibPath, finalLibs, [], [])
# Add a program integrated in the Xmipp structure
def AddXmippTest(name):
    testprog = AddXmippProgram(name, ['gtest'], 'tests')
    testname = 'xmipp_' + name
    xmlFileName='applications/tests/OUTPUT/' + testname + ".xml"
    if  os.path.exists(xmlFileName):
       os.remove(xmlFileName)
    testcase = env.Alias('run_' + name , env.Command(xmlFileName,testname,
                                   "$SOURCE --gtest_output=xml:$TARGET"))
    env.Depends(testcase, testprog)
    test = env.Alias('run_tests',testcase)
    AlwaysBuild(testcase)
    #env.Default(test)

def AddXmippMPIProgram(name, libs=[]):
    finalLibPath = ['lib']
    finalIncludePath = ['libraries', '#']
    finalLibs = libs + ['XmippData', 'XmippExternal', 'XmippParallel'] + FFTWLibs + SQLiteLibs + TIFFLibs
    for i in range(len(libs)):
       if libs[i] == 'XmippRecons':
          finalLibPath += ['libraries/reconstruction']
       elif libs[i] == 'XmippInterface':
          finalLibPath += ['libraries/interface']
       elif libs[i] == 'XmippRecons_Interface':
          finalLibPath += ['libraries/interface']
          finalLibs.insert(i + 1, 'XmippInterface')
       elif libs[i] == 'XmippReconsMPI':
          finalLibPath += ['libraries/reconstruction_mpi']
       elif libs[i] == 'XmippClassif':
          finalLibPath += ['libraries/classification']
    AddMPIProgram(name, 'applications/programs/' + name, '*.cpp', [],
        finalIncludePath, finalLibPath, finalLibs, [], [])

# For Roberto's new lib
def AddMPILibrary(name, basedir, sources, includes, libpath=[], libs=[]):
    # setup
    basedir = AddLastSlash(basedir)
    libprefix = os.path.join(env['prefix'], 'lib')
    #for x in sources:
    #    sources[sources.index(x)] = basedir + x

    # separate local and global includes
    for x in includes:
        if x[0] != '#':
            includes[includes.index(x)] = basedir + x

    # action
    # FIXME Exclusive may not be what users want
    if int(env['static']):
        library = env.StaticLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']] + [env['MPI_INCLUDE']],
            CC=env['MPI_CC'],
            CXX=env['MPI_CXX'],
            LIBPATH=[env['MPI_LIBDIR']] + libpath,
            LIBS=[env['MPI_LIB']] + libs
            )
    else:
        library = env.SharedLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']] + [env['MPI_INCLUDE']],
            CC=env['MPI_CC'],
            CXX=env['MPI_CXX'],
            LIBPATH=[env['MPI_LIBDIR']] + libpath,
            LIBS=[env['MPI_LIB']] + libs
            )

    # alias
    alias = env.Alias(name, library)
    install = env.Install(libprefix, library)
    env.Alias(name, install)
    env.Default(alias)

def AddLibrary(name, basedir, sources, includes, libpath=[], libs=[],
    shlibprefix='lib'):
    # setup
    basedir = AddLastSlash(basedir)
    libprefix = os.path.join(env['prefix'], 'lib')
    for x in sources:
        if x.find(basedir) == -1:
            sources[sources.index(x)] = basedir + x

    # separate local and global includes
    for x in includes:
        if x[0] != '#' and x[0] != '/':
            includes[includes.index(x)] = basedir + x

    # action
    # FIXME Exclusive may not be what users want
    # Sjors: Hack for OS X compilation (static libs, dynamic apps...??)
    if int(env['static']) or (env['PLATFORM'] == 'darwin'):
        library = env.StaticLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']],
            LIBPATH=libpath,
            LIBS=libs
            )
    else:
        library = env.SharedLibrary(
            basedir + name,
            sources,
            CPPPATH=includes + [env['CPPPATH']],
            LIBPATH=libpath,
            LIBS=libs,
            SHLIBPREFIX=shlibprefix
            )

    install = env.Install(libprefix, library)
    alias = env.Alias(name, install)
    env.Default(alias)
    return alias

def AddJavaLibrary(name, basedir, srcdir):#, sourceList, includes, libpath=[], libs=[]):
    buildDir = os.path.join(basedir, 'classes')
    if not os.path.exists(buildDir): # create classes dir if not exists
        Execute(Mkdir(buildDir))    
    buildClasses = env.Java(buildDir, basedir, JAVAVERSION='1.6')
    env.Depends(buildClasses, env.Alias('javaEnums'))
    jarfile = os.path.join(basedir, name + '.jar')
    buildJar = env.Jar(target=jarfile, source=buildClasses, JARCHDIR=buildDir)
    alias = env.Alias(name, buildJar)
    env.Default(alias)
    return alias

def removeAll(basedir, regexp):
	import glob

	files = glob.glob(basedir + regexp)
	for i in range(len(files)):
		os.remove(files[i])

def AddJavaApp(name, appDir, outDir):
    import shutil
    sourceDir = os.path.join(appDir, 'src')
    resourcesDir = os.path.join(sourceDir, 'resources')
    libsDir = os.path.join(appDir ,'libs')
    metainfDir = os.path.join(sourceDir, 'META-INF')
    buildDir = os.path.join(appDir ,'build')
    buildResourcesDir = os.path.join(buildDir, 'resources')
    buildMetainf = os.path.join(buildDir, 'META-INF')
    outLibsDir = os.path.join(outDir, 'libs')
    # Clears "buildDir"
    if not os.path.exists(buildDir):
        os.mkdir(buildDir)
        #os.mkdir(buildResourcesDir)
    buildClasses = env.Java(buildDir, sourceDir, JAVAVERSION='1.6')
    # Copies MANIFEST
    copyMetainf = env.Install(buildMetainf, Glob(metainfDir, "MANIFEST.MF", []))
    buildJar = env.Jar(os.path.join(outDir, name + '.jar'), buildDir, JARCHDIR=buildDir)
    
    appLibs = {}
    jarList = Glob(libsDir, "*.jar", [])
    for l in jarList:
        lname = os.path.basename(l)
        if not appLibs.has_key(lname):
            install = env.Install(outLibsDir, l)
            appLibs[lname] = install
        env.Depends(buildClasses, appLibs[lname])
        
    copyPluginResources = env.Install(buildResourcesDir, Glob(resourcesDir, "*?.???", []))
    env.Depends(buildJar, [copyMetainf, copyPluginResources, buildClasses])
    pluginAlias = env.Alias(name, buildJar)
    env.Depends(buildClasses, copyJar)
    
    return pluginAlias

def AddImageJPlugin(name, pluginDir, outDir):
    import shutil
    sourceDir = os.path.join(pluginDir, 'src')
    resourcesDir = os.path.join(sourceDir, 'resources')
    libsDir = os.path.join(pluginDir ,'libs')
    macrosDir = os.path.join(pluginDir ,'macros')
    buildDir = os.path.join(pluginDir ,'build')
    buildResourcesDir = os.path.join(buildDir, 'resources')
    # Clears "buildDir"
    if not os.path.exists(buildDir):
        os.mkdir(buildDir)
        os.mkdir(buildResourcesDir)
    # Copies 'plugins.config' to build dir...    
    buildClasses = env.Java(buildDir, sourceDir, JAVAVERSION='1.6')
    copyPluginConfig = env.Install(buildDir, os.path.join(sourceDir, 'plugins.config'))#Glob(sourceDir, 'plugins.config', []))
    buildJar = env.Jar(os.path.join(outDir, name + '.jar'), buildDir, JARCHDIR=buildDir)
    
    jarList = Glob(libsDir, "*.jar", [])
    for l in jarList:
        lname = os.path.basename(l)
        if not PluginLibs.has_key(lname):
            install = env.Install(outDir, l)
            PluginLibs[lname] = install
        env.Depends(buildClasses, PluginLibs[lname])
        
    copyPluginResources = env.Install(buildResourcesDir, Glob(resourcesDir, "*?.???", []))          
    env.Depends(buildJar, [copyPluginConfig, copyPluginResources, buildClasses])  
    pluginAlias = env.Alias(name, buildJar)
    env.Depends(buildClasses, copyJar)
    
    outMacrosDir = os.path.join(outDir, "..", "macros")
    env.Alias('copyMacros', env.Install(outMacrosDir, Glob(macrosDir, "*?.???", [])))  
    return pluginAlias

def AddExternalLibrary(libname, libs, libpath, suffix):
    libprefix = os.path.join(env['prefix'], 'lib')
    numJobs = env.GetOption('num_jobs')
    
    target_libs = []
    
    if int(env['static']):
        lib_ext = ".a"
    else:
        if env['PLATFORM'] == 'darwin':
            lib_ext = ".dylib"
        else:
            lib_ext = ".so"
    
    for lib in libs:
        lib_name = lib + lib_ext
        target_libs.append(os.path.join(libpath, lib_name))
        target_libs.append(os.path.join(libpath, lib + '.la'))
        if not int(env['static']) and env['PLATFORM'] != 'darwin':
            target_libs.append(os.path.join(libpath, lib_name + suffix))
            
    logFile = os.path.join("..", "..", "build", libname + "_make.log")
    env.Command(target_libs, Glob(libpath, "*/*.c", []),
                         'cd %s; make clean > /dev/null; make > %s;' 
                         % (libpath, logFile))
    libInstall = env.Install(libprefix, target_libs)
    libAlias = env.Alias(libname, libInstall)
    env.Default(libAlias)
    return libInstall
    
def AddSQLiteLibrary():
    libInstall = AddExternalLibrary('sqlite', ['.libs/libsqlite3'], SQliteDir, '.0')
    progName = os.path.join(SQliteDir, 'sqlite3')
    Depends(progName, libInstall)
    progXmippName = os.path.join(env['prefix'], 'bin', 'xmipp_sqlite3')
    progInstall = env.InstallAs(progXmippName, progName)
    progAlias = env.Alias('sqlite', progInstall)
    env.Default(progAlias)
    return progAlias

def AddPySqliteLibrary():
    libprefix = os.path.join(env['prefix'], 'lib')
    pysqlite2Target = libprefix + '/pysqlite2/'
    pysqlite2Build = env.Command(pysqlite2Target, PYSQliteDir, \
                          'cd  $SOURCE ; python ./setup.py build ' + \
			  ' ; python ./setup.py install --install-lib ' + libprefix + \
			  ' --install-data ' + libprefix + '/pysqlite2')
    Depends(pysqlite2Build, env.Alias('sqlite'))
    alias = env.Alias('pysqlite2', pysqlite2Target)
    env.Default(alias)


# --- Libraries

# SQLite
sqlite = AddSQLiteLibrary()

# PYSQLITE
PYSQliteDir = "external/pysqlite-2.6.3"
AddPySqliteLibrary()

# FFTW
FFTWLibsPaths = ['.libs/libfftw3', 'threads/.libs/libfftw3_threads']
fftw = AddExternalLibrary('fftw', FFTWLibsPaths, FFTWDir, '.3')

# TIFF
TIFFLibsPaths = ['libtiff/.libs/libtiff']
tiff = AddExternalLibrary('tiff', TIFFLibsPaths, TIFFDir, '.3')

# Gtest
if int(env['gtest']):
    DataSources = Glob('external/gtest-1.6.0/fused-src/gtest', 'gtest-all.cc', [])
    AddLibrary('gtest', 'external/gtest-1.6.0/fused-src/gtest', DataSources, ['#'],
               [], [])

# Bilib
BilibSources = Glob('external/bilib/sources', '*.cc', [])

# INRIA
INRIASources = Glob('external/inria', '*.cc', [])

# Condor
CondorSources = Glob('external/condor', '*.cpp', [])

AddLibrary('XmippExternal', 'external',
   INRIASources + BilibSources + CondorSources,
   ['bilib', 'bilib/headers', 'bilib/types'])

# XmippData
DataSources = Glob('libraries/data', '*.cpp', [])
AddLibrary('XmippData', 'libraries/data', DataSources, ['#'],
           ['lib'], ['XmippExternal'] + FFTWLibs + TIFFLibs + SQLiteLibs)

#Xmipp Python Extension
PyExtSources = Glob('libraries/bindings/python', '*.cpp', [])
import distutils.sysconfig
AddLibrary('xmipp', 'libraries/bindings/python', PyExtSources,
           ['#libraries', "#", distutils.sysconfig.get_python_inc()],
           ['lib'], ['XmippData'], '')

# Reconstruction
ReconsSources = [
    'adjust_volume_grey_levels.cpp',
    'align2d.cpp',
    'align_tilt_pairs.cpp',
    'angular_commonline.cpp',
    'angular_continuous_assign.cpp',
    'angular_discrete_assign.cpp',
    'angular_distance.cpp',
    'angular_neighbourhood.cpp',
    'angular_projection_matching.cpp',
    'angular_class_average.cpp',
    'angular_project_library.cpp',
    'art_crystal.cpp',
    'basic_art.cpp',
    'convert_vol2pseudo.cpp',
    'correct_bfactor.cpp',
    'ctf_correct_amplitude3d.cpp',
    'ctf_correct_idr.cpp',
    'ctf_enhance_psd.cpp',
    'ctf_estimate_from_micrograph.cpp',
    'ctf_estimate_from_psd.cpp',
    'ctf_estimate_psd_with_arma.cpp',
    'ctf_group.cpp',
    'ctf_sort_psds.cpp',
    'denoise.cpp',
    'detect_missing_wedge.cpp',
##    'detect_structures.cpp',
    'directions.cpp',
    'enhance_contrast.cpp',
    'filter_projections.cpp',
    'fourier_filter.cpp',
    'make_spectra.cpp',
    'micrograph_phase_flipping.cpp',
    'ml_align2d.cpp',
###    'ml_align3d.cpp',
    'mean_shift.cpp',
    'mlf_align2d.cpp',
    'ml_refine3d.cpp',
    'ml_tomo.cpp',
    'ml2d.cpp',
    'nma_alignment.cpp',
#    'phantom_create_micrograph.cpp',
    'phantom_create_random.cpp',
    'phantom_simulate_microscope.cpp',
    'precompute_sampling.cpp',
    'program_extension.cpp',
    'project.cpp',
    'project_crystal.cpp',
    'project_XR.cpp',
    'projection_real_shears.cpp',
    'projectTomography.cpp',
    'radon.cpp',
    'recons_misc.cpp',
    'reconstruct_art.cpp',
    'reconstruct_art_pseudo.cpp',
    'reconstruct_fourier.cpp',
    'reconstruct_wbp.cpp',
    'refinement.cpp',
    'resolution_ibw.cpp',
    'resolution_ssnr.cpp',
    'symmetrize.cpp',
    'threshold.cpp',
    'tomo_align_dual_tilt_series.cpp',
    'tomo_align_tilt_series.cpp',
    'tomo_align_refinement.cpp',
    'tomo_remove_fluctuations.cpp',
    'transform_downsample.cpp',
    'volume_from_pdb.cpp',
    'volume_segment.cpp',
    'xray_import.cpp'
]

AddLibrary('XmippRecons', 'libraries/reconstruction', ReconsSources,
           ['#libraries', '#external', '#'], ['lib'], ['XmippExternal', 'XmippData', 'pthread'])

# Classification
ClassificationSources = Glob('libraries/classification', '*.cpp', [])
AddLibrary('XmippClassif', 'libraries/classification', ClassificationSources,
    ['#libraries', '#'], ['lib'], ['XmippExternal', 'XmippData'])

# XmippParallel
if int(env['mpi']):
    ParallelSources = Glob('libraries/parallel', '*.cpp', []);
    AddMPILibrary("XmippParallel", 'libraries/parallel', ParallelSources, ["#", "#libraries", "#external"],
              ['lib'], ['XmippExternal', 'XmippData', 'XmippRecons', 'XmippClassif'] + FFTWLibs + TIFFLibs + SQLiteLibs)

# Interface
InterfaceSources = Glob('libraries/interface', '*.cpp', [])
AddLibrary('XmippInterface', 'libraries/interface', InterfaceSources,
    ['#libraries', '#external', '#'], ['lib'], ['XmippExternal', 'XmippData', 'pthread'])

# Recons Interface
#AddLibrary('XmippRecons_Interface', '#libraries/reconstruction',
#           ReconsInterfaceSources, ['#libraries', '#external', '#'],['lib'],['XmippExternal','XmippData','XmippRecons','XmippInterface'])

def WriteJavaEnum(class_name, header_file, pattern, log):
    java_file = "libraries/bindings/java/xmipp/%s.java" % class_name
    env.Depends(java_file, header_file)
    f = open(header_file) 
    fOut = open(java_file, 'w+')    
    counter = 0;    
    last_label_pattern = pattern + "LAST_LABEL"
    fOut.write("package xmipp; \n")
    fOut.write("public class " + class_name + " {\n")
    
    for line in f:
        l = line.strip();
        if l.startswith(pattern):
            
            if l.startswith(last_label_pattern):
                l = l.replace(last_label_pattern, last_label_pattern + " = " + str(counter) + ";")   
            if (l.find("=") == -1):
                l = l.replace(",", " = " + str(counter) + "; ")   
                counter = counter + 1;
            else:
                l = l.replace(",", ";")                                       
                
            fOut.write("   public static final int %s\n" % l)    

    fOut.write("}\n")
    fOut.close()
    f.close()
    # Write log file
    if log:
        from datetime import datetime 
        d = str(datetime.now())
        #d = date.today();
        log.write("Java file '%s' successful generated at %s\n" % (java_file, d))
    
def ExtractEnumFromHeader(source, target, env):
    # this is very ugly, we still need more scons knowledge

    log = open(str(target[0]), 'w+')
    for (class_name, list) in javaEnumDict.iteritems():
        WriteJavaEnum(class_name, list[0], list[1], log)
    
    log.close()
    return None

# ImageJ plugins.
# Installs jvm
if int(env['java']):
    # Update enums from c++ headers, if not exist, generate it 
    for (class_name, list) in javaEnumDict.iteritems():
       java_file = "libraries/bindings/java/xmipp/%s.java" % class_name
       if not os.path.exists(java_file):
          WriteJavaEnum(class_name, list[0], list[1], None) 
    
    env.Alias('javaEnums', env.Command("libraries/bindings/java/xmipp/enums.changelog", 
                            ["libraries/data/image_base.h","libraries/data/metadata_label.h" ], ExtractEnumFromHeader))
    JavaInterfaceSources = Glob('libraries/bindings/java', '*.cpp', [])
    javaJni = AddLibrary('XmippJavaInterface', 'libraries/bindings/java', JavaInterfaceSources,
    ['#libraries', '#external', '#']+env['JNI_CPPPATH'], ['lib'],
    ['XmippData', 'pthread'])

    env.Append(JAVACLASSPATH='external/imagej/ij.jar:external/imagej/plugins/*:libraries/bindings/java')
    env['ENV']['LANG'] = 'en_GB.UTF-8'
    env['JARFLAGS'] = '-Mcf'    # Default "cf". "M" = Do not add a manifest file.

    # Xmipp interface is needed by plugins.
    javaLib = AddJavaLibrary('XmippJavaInterface', 'libraries/bindings/java', 'xmipp')#, ['#'],
    # Copies jar file to ImageJ plugins folder (plugins below will look for it there).
    copyJar = env.InstallAs(target='external/imagej/plugins/XmippJavaInterface.jar',
              source='libraries/bindings/java/XmippJavaInterface.jar')
    # ImageJ plugins. 
    javaPlugins = []   
    javaPlugins.append(AddImageJPlugin('Xmipp_IO', 'libraries/graphicsj/Xmipp_IO', 'external/imagej/plugins'))
    javaPlugins.append(AddImageJPlugin('Xmipp_Projections_Explorer', 'libraries/graphicsj/Xmipp_Projections_Explorer', 'external/imagej/plugins'))
    javaPlugins.append(AddImageJPlugin('Xmipp_Browser', 'libraries/graphicsj/Xmipp_Browser', 'external/imagej/plugins'))
    javaPlugins.append(AddImageJPlugin('Xmipp_Tomo', 'libraries/graphicsj/Xmipp_Tomo', 'external/imagej/plugins'))
    # Java apps
    javaPlugins.append(AddJavaApp('Java3DInstaller', 'libraries/graphicsj/Java3DInstaller', 'external/Java3DInstaller'))

    import sys
    sys.path.append("scons/ToolsFromWiki")
    import install
    install.TOOL_INSTALL(env)
    javaExtPlugins = env.InstallFiles('external/imagej/plugins', 'libraries/graphicsj/plugins', exclude='.svn')
    javaAlias = env.Alias('java', [javaJni, javaLib, copyJar, javaExtPlugins, env.Alias('copyMacros')] + javaPlugins) 
    env.Default(javaAlias)

# --- Programs

# Src (apps)

AddXmippProgram('angular_class_average', ['XmippRecons'])
AddXmippProgram('angular_commonline', ['XmippRecons'])
AddXmippProgram('angular_continuous_assign', ['XmippRecons'])
AddXmippProgram('angular_discrete_assign', ['XmippRecons'])
AddXmippProgram('angular_distance', ['XmippRecons'])
AddXmippProgram('angular_distribution_show', ['XmippInterface'])
AddXmippProgram('angular_neighbourhood', ['XmippRecons'])
AddXmippProgram('angular_projection_matching', ['XmippRecons'])
AddXmippProgram('angular_project_library', ['XmippRecons'])
AddXmippProgram('angular_rotate')
AddXmippProgram('apropos', ['XmippInterface'])
AddXmippProgram('classify_analyze_cluster', ['XmippClassif'])
AddXmippProgram('classify_kerdensom', ['XmippClassif'])
AddXmippProgram('convert_vol2pseudo', ['XmippRecons'])
AddXmippProgram('convert_voxels22blobs', ['XmippRecons'])
AddXmippProgram('correct_bfactor', ['XmippRecons'])
AddXmippProgram('ctf_correct_amplitude3d', ['XmippRecons'])
AddXmippProgram('ctf_correct_idr', ['XmippRecons'])
AddXmippProgram('ctf_create_ctfdat', ['XmippRecons'])
AddXmippProgram('ctf_enhance_psd', ['XmippRecons'])
AddXmippProgram('ctf_estimate_from_micrograph', ['XmippRecons'])
AddXmippProgram('ctf_estimate_from_psd', ['XmippRecons'])
AddXmippProgram('ctf_group', ['XmippRecons'])
AddXmippProgram('ctf_sort_psds', ['XmippRecons'])
#AddXmippProgram('denoise', ['XmippRecons'])
AddXmippProgram('detect_missing_wedge', ['XmippRecons'])
#AddXmippProgram('detect_structures', ['XmippRecons'])
AddXmippProgram('enhance_contrast', ['XmippRecons'])
AddXmippProgram('filter_projections', ['XmippRecons'])
AddXmippProgram('find_center2d')
AddXmippProgram('find_center3d')
AddXmippProgram('image_align', ['XmippRecons'])
AddXmippProgram('image_align_tilt_pairs', ['XmippRecons'])
AddXmippProgram('image_convert')
AddXmippProgram('image_header')
AddXmippProgram('image_histogram')
AddXmippProgram('image_operate')
AddXmippProgram('image_sort', ['XmippClassif'])
AddXmippProgram('image_separate_objects')
AddXmippProgram('image_statistics')
AddXmippProgram('image_vectorize')
AddXmippProgram('make_spectra', ['XmippRecons'])
#AddXmippProgram('mean_shift')
AddXmippProgram('metadata_convert_to_spider', ['XmippInterface'])
AddXmippProgram('metadata_histogram')
AddXmippProgram('metadata_import')
AddXmippProgram('metadata_split')
AddXmippProgram('metadata_utilities')
AddXmippProgram('micrograph_phase_flipping', ['XmippRecons'])
AddXmippProgram('micrograph_scissor'),
AddXmippProgram('ml_align2d', ['XmippRecons'])
AddXmippProgram('mlf_align2d', ['XmippRecons'])
AddXmippProgram('ml_refine3d', ['XmippRecons'])
AddXmippProgram('mlf_refine3d', ['XmippRecons'])
AddXmippProgram('ml_tomo', ['XmippRecons'])
AddXmippProgram('mrc_create_metadata')
AddXmippProgram('nma_alignment', ['XmippRecons'])
AddXmippProgram('phantom_create', ['XmippRecons'])
#AddXmippProgram('phantom_create_micrograph', ['XmippRecons'])
AddXmippProgram('phantom_create_random', ['XmippRecons'])
AddXmippProgram('phantom_project', ['XmippRecons', 'XmippInterface'])
AddXmippProgram('phantom_simulate_microscope', ['XmippRecons'])
AddXmippProgram('phantom_transform', ['XmippRecons', 'XmippInterface'])
AddXmippProgram('projection_real_shears', ['XmippRecons'])
#Sjors: note that crystal stuff in ART is not working yet....
AddXmippProgram('reconstruct_art', ['XmippRecons'])
AddXmippProgram('reconstruct_art_pseudo', ['XmippRecons'])
AddXmippProgram('reconstruct_wbp', ['XmippRecons'])
AddXmippProgram('reconstruct_fourier', ['XmippRecons'])
AddXmippProgram('resolution_fsc')
AddXmippProgram('resolution_ibw', ['XmippRecons'])
AddXmippProgram('resolution_ssnr', ['XmippRecons'])
AddXmippProgram('transform_add_noise')
AddXmippProgram('transform_adjust_volume_grey_levels', ['XmippRecons'])
AddXmippProgram('transform_center_image')
AddXmippProgram('transform_downsample', ['XmippRecons'])
AddXmippProgram('transform_filter', ['XmippRecons'])
AddXmippProgram('transform_geometry')
AddXmippProgram('transform_mask')
AddXmippProgram('transform_mirror')
AddXmippProgram('transform_morphology')
AddXmippProgram('transform_normalize')
AddXmippProgram('transform_range_adjust')
AddXmippProgram('transform_symmetrize', ['XmippRecons'])
AddXmippProgram('transform_threshold', ['XmippRecons'])
AddXmippProgram('transform_window')
#AddXmippProgram('test_program')
#AddXmippProgram('test_sql')

AddXmippProgram('template_threads')
AddXmippProgram('tomo_align_dual_tilt_series', ['XmippRecons'])
AddXmippProgram('tomo_align_refinement', ['XmippRecons'])
AddXmippProgram('tomo_align_tilt_series', ['XmippRecons'])
AddXmippProgram('tomo_project', ['XmippRecons'])
AddXmippProgram('tomo_remove_fluctuations', ['XmippRecons'])
AddXmippProgram('volume_align')
AddXmippProgram('volume_reslice')
AddXmippProgram('volume_segment', ['XmippRecons'])
AddXmippProgram('xray_import', ['XmippRecons'])
AddXmippProgram('xray_psf_create')
AddXmippProgram('xray_project', ['XmippRecons'])

#---- Test
if int(env['gtest']):
     AddXmippTest('test_metadata')
     AddXmippTest('test_multidim')
     env.Depends('run_tests', [fftw, tiff, sqlite])
     env.Default('run_tests'     )

# --- Scripts

# Batches (apps)
#
AddBatch('metadata_selfile_create', 'applications/scripts/metadata_selfile_create', '.py')
AddBatch('metadata_show', 'applications/scripts/metadata_show', '.py')
#AddBatch('metadata_operate', 'applications/scripts/metadata_operate','.py')
AddBatch('classify_CL2D_core_analysis', 'applications/scripts/classify_CL2D_core_analysis')
AddBatch('convert_img2jpg', 'applications/scripts/convert_img2jpg')
AddBatch('convert_lst2sel', 'applications/scripts/convert_lst2sel')
AddBatch('convert_pdb2descr', 'applications/scripts/convert_pdb2descr')
AddBatch('extract_sidechain_from_pdb', 'applications/scripts/extract_sidechain_from_pdb', '.pl')
AddBatch('convert_vol2jpg', 'applications/scripts/convert_vol2jpg')
AddBatch('convert_pdb2surface', 'applications/scripts/convert_pdb2surface')
AddBatch('protocols', 'applications/scripts/protocols')
AddBatch('gui', 'applications/scripts/protocols')
AddBatch('showj', 'applications/scripts/showj', '.sh')
AddBatch('projections_explorerj', 'applications/scripts/projections_explorerj', '.sh')
AddBatch('visualize_preprocessing_micrographj', 'applications/scripts/visualize_preprocessing_micrograph', '.sh')
AddBatch('browserj', 'applications/scripts/browserj', '.sh')
# AddBatch('convert_tia2raw', 'applications/programs/convert_tia2raw')
AddBatch('move_along_NMAmode', 'applications/scripts/move_along_NMAmode', '.pl')

# Protocols
AddProtocol('arg.py', 'applications/scripts/protocols')
AddProtocol('apply_bfactor.py', 'applications/scripts/protocols')
AddProtocol('xmipp_config.py', 'applications/scripts/protocols')
AddProtocol('ctfdat.py', 'applications/scripts/protocols')
AddProtocol('launch_job.py', 'applications/scripts/protocols')
AddProtocol('log.py', 'applications/scripts/protocols')
AddProtocol('not_implemented.py', 'applications/scripts/protocols')
AddProtocol('rename_files.py', 'applications/scripts/protocols')
AddProtocol('spider_header.py', 'applications/scripts/protocols')
AddProtocol('utils_xmipp.py', 'applications/scripts/protocols')
AddProtocol('metadataUtils.py', 'applications/scripts/protocols')
AddProtocol('visualization.py', 'applications/scripts/protocols')
AddProtocol('visualize_kerdensom.py', 'applications/scripts/protocols')
AddProtocol('visualize_ml2d.py', 'applications/scripts/protocols')
AddProtocol('visualize_cl2d.py', 'applications/scripts/protocols')
AddProtocol('visualize_ml3d.py', 'applications/scripts/protocols')
AddProtocol('visualize_multires.py', 'applications/scripts/protocols')
AddProtocol('visualize_preprocess_micrographs.py', 'applications/scripts/protocols')
AddProtocol('visualize_preprocess_particles.py', 'applications/scripts/protocols')
AddProtocol('visualize_projmatch.py', 'applications/scripts/protocols')
AddProtocol('visualize_rct.py', 'applications/scripts/protocols')
AddProtocol('visualize_rotspectra.py', 'applications/scripts/protocols')
AddProtocol('which.py', 'applications/scripts/protocols')

AddProtocol('protocol_gui.py', 'applications/scripts/protocols')
AddProtocol('protocol_align2d.py', 'applications/scripts/protocols')
AddProtocol('protocol_backup.py', 'applications/scripts/protocols')
AddProtocol('protocol_cl2d.py', 'applications/scripts/protocols')
AddProtocol('protocol_commonlines.py', 'applications/scripts/protocols')
AddProtocol('protocol_kerdensom.py', 'applications/scripts/protocols')
AddProtocol('protocol_ml2d.py', 'applications/scripts/protocols')
AddProtocol('protocol_ml3d.py', 'applications/scripts/protocols')
AddProtocol('protocol__mltomo.py', 'applications/scripts/protocols')
AddProtocol('protocol_multires.py', 'applications/scripts/protocols')
AddProtocol('protocol_particle_pick.py', 'applications/scripts/protocols')
AddProtocol('protocol_preprocess_micrographs.py', 'applications/scripts/protocols')
AddProtocol('protocol_preprocess_particles.py', 'applications/scripts/protocols')
AddProtocol('protocol_projmatch.py', 'applications/scripts/protocols')
AddProtocol('protocol_rct.py', 'applications/scripts/protocols')
AddProtocol('protocol_rotspectra.py', 'applications/scripts/protocols')
AddProtocol('protocol_setup.py', 'applications/scripts/protocols')

# MPI
if int(env['mpi']):
    AddXmippMPIProgram('mpi_angular_class_average', ['XmippRecons'])
    AddXmippMPIProgram('mpi_angular_continuous_assign', ['XmippRecons'])
    AddXmippMPIProgram('mpi_angular_projection_matching', ['XmippRecons'])
    AddXmippMPIProgram('mpi_angular_project_library', ['XmippRecons'])
    AddXmippMPIProgram('mpi_classify_CL2D', ['XmippRecons'])
#    AddXmippMPIProgram('mpi_ctf_correct_idr', ['XmippRecons'])
    AddXmippMPIProgram('mpi_ml_align2d', ['XmippRecons'])
#    # AddXmippMPIProgram('mpi_ml_tomo', ['XmippRecons'])
#    AddXmippMPIProgram('mpi_mlf_align2d', ['XmippRecons'])
    AddXmippMPIProgram('mpi_ml_refine3d', ['XmippRecons'])
#    AddXmippMPIProgram('mpi_mlf_refine3d', ['XmippRecons'])
    AddXmippMPIProgram('mpi_nma_alignment', ['XmippRecons'])
    AddXmippMPIProgram('mpi_projection_real_shears', ['XmippRecons'])
    AddXmippMPIProgram('mpi_xray_project', ['XmippRecons'])
#    AddXmippMPIProgram('mpi_reconstruct_art', ['XmippRecons'])
    AddXmippMPIProgram('mpi_reconstruct_wbp', ['XmippRecons'])
    AddXmippMPIProgram('mpi_reconstruct_fourier', ['XmippRecons'])
    AddXmippMPIProgram('mpi_run', ['XmippRecons'])
    AddXmippMPIProgram('mpi_sort_images', ['XmippRecons'])
#    AddXmippMPIProgram('template_threads', ['XmippRecons'])
#    AddXmippMPIProgram('template_mpi', ['XmippRecons'])
# QT
if int(env['gui']):
    envQT = env.Clone()

    if int(env['QT4']):
        # FIXME see SConstruct
        env['QTDIR'] = ''
        env['QT_LIB'] = ''

        envQT.Tool('qt4')
        envQT.EnableQt4Modules(['QtCore', 'QtGui', 'Qt3Support'], debug=False)

        # Fix for moc and #ifdefs (qt3 uses MOC_SKIP_*)
        envQT['QT4_MOCFROMHFLAGS'] += ['-DQT3_SUPPORT']
        envQT['QT4_MOCFROMCXXFLAGS'] += ['-DQT3_SUPPORT']

    else:
        envQT.Tool('qt')

        # QT_AUTOSCAN does not work because .h and .cpp are not in the same dir
        # envQT.SetDefault(QT_AUTOSCAN = 1)

        # Once again, just in case, Copy() does not work too well
        envQT.Replace(QT_LIB=env['QT_LIB'])

    def AddQtProgram(name, basedir, sources_pattern='*.cpp', skip_list=[],
        mocs=[], includes=[], libpath=[], libs=[], cxxflags=[],
        linkflags=[]):

        # setup
        basedir = AddLastSlash(basedir)
        fullname = env['prepend'] + name
        binprefix = os.path.join(env['prefix'], 'bin')

        extra = []

        if int(env['QT4']):
            for i in mocs:
                extra.append(envQT.Moc4(basedir + i))
        else:
            for i in mocs:
                extra.append(envQT.Moc(basedir + i))

        sources = Glob(basedir, sources_pattern, skip_list)

        program = envQT.Program(
            basedir + env['prepend'] + name,
            sources + extra,
            CPPPATH=envQT['CPPPATH'] + includes + [env['CPPPATH']],
            LIBPATH=envQT['LIBPATH'] + libpath + [env['LIBPATH']],
            LIBS=envQT['LIBS'] + libs + [env['LIBS']] + TIFFLibs,
            CXXFLAGS=cxxflags + [env['CXXFLAGS']],
            LINKFLAGS=linkflags + [env['LINKFLAGS']],
            LINK=env['LINKERFORPROGRAMS']
            )

        # alias
        alias = env.Alias(fullname, program)
        install = env.Install(binprefix, program)
        env.Alias(fullname, install)
        env.Default(alias)

    # FIXME an AddQtLibrary function does not worth the cost, right?
    graphics_name = 'XmippGraphics'
    graphics_basedir = AddLastSlash('libraries/graphics')

    graphics_sources = Glob(graphics_basedir, '*.cpp', [])
    graphics_cpppath = envQT['CPPPATH'] + ['libraries', '#']

    graphics_objects = []
    for i in graphics_sources:
        graphics_objects.append(i)

    if int(env['static']):
        graphics = envQT.StaticLibrary(
            graphics_basedir + graphics_name,
            graphics_objects,
            CPPPATH=graphics_cpppath
            )
    else:
        graphics = envQT.SharedLibrary(
            graphics_basedir + graphics_name,
            graphics_objects,
            CPPPATH=graphics_cpppath
            )

    graphics_alias = env.Alias(graphics_name, graphics)
    graphics_install = env.Install(os.path.join(env['prefix'], 'lib'),
        graphics)
    env.Alias(graphics_name, graphics_install)
    env.Default(graphics_alias)

    # Add a program integrated in the Xmipp structure
    def AddXmippQtProgram(name, mocs=[], libs=[]):
        finalLibPath = ['lib']
        finalIncludePath = ['libraries', '#']
        finalLibs = ['XmippData', 'XmippExternal', 'XmippGraphics',
            'XmippRecons', 'XmippClassif'] + FFTWLibs + SQLiteLibs + libs
        for i in range(len(libs)):
           if libs[i] == 'XmippInterface':
    	      finalLibPath += ['libraries/interface']
           elif libs[i] == 'XmippRecons_Interface':
    	      finalLibPath += ['libraries/interface']
              finalLibs += ['XmippInterface']
        AddQtProgram(name, 'applications/programs/' + name, '*.cpp', [], mocs,
    	    finalIncludePath, finalLibPath, finalLibs, [], [])

    AddXmippQtProgram('micrograph_mark', ['popup_menu_mark.h'])
    AddXmippQtProgram('show', [], ['XmippClassif', 'XmippRecons'])
    AddXmippQtProgram('mask_design', [], ['XmippClassif'])

if int(env['matlab']):
    import os

    def AddMatlabBinding(name):
        print 'compiling Matlab wrapper for ' + name
        command = env['MATLAB_DIR'] + '/bin/mex -O -outdir libraries/bindings/matlab -I. -Ilibraries/data -Ilibraries -Llib -Ilibraries/reconstruction -lXmippRecons -lXmippData -lXmippExternal libraries/bindings/matlab/tom_xmipp_' + name + '_wrapper.cpp'
        output = os.popen(command).read()
        if len(output) > 0:
            print output

    bindings = ['adjust_ctf', 'align2d', 'ctf_correct_phase',
        'mask', 'mirror', 'morphology', 'normalize', 'psd_enhance',
        'resolution', 'rotate', 'scale', 'scale_pyramid', 'volume_segment']

    for i in range(len(bindings)):
       AddMatlabBinding(bindings[i])

# Clean
# Configuration or cleaning
if env.GetOption('clean'):
    print '* Cleaning  ...'
    os.system("( cd external/fftw-3.2.2    ; make clean >& /dev/null )");
    os.system("( cd external/sqlite-3.6.23 ; make clean >& /dev/null )");
